//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdvertisementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAdvertisement(body: ApiCreateAdvertisementDto | undefined): Observable<ApiCreatAdvertisementOut> {
        let url_ = this.baseUrl + "/api/Advertisement/CreateAdvertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdvertisement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreatAdvertisementOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreatAdvertisementOut>;
        }));
    }

    protected processCreateAdvertisement(response: HttpResponseBase): Observable<ApiCreatAdvertisementOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreatAdvertisementOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdvertiseDetailsForEdit(body: ApiAdvertisesInput | undefined): Observable<ApiCreatAdvertisementOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertiseDetailsForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertiseDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertiseDetailsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreatAdvertisementOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreatAdvertisementOut>;
        }));
    }

    protected processGetAdvertiseDetailsForEdit(response: HttpResponseBase): Observable<ApiCreatAdvertisementOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreatAdvertisementOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdvertiseDetails(body: ApiAdvertisesInput | undefined): Observable<ApiAdvertiseDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertiseDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertiseDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertiseDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiAdvertiseDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiAdvertiseDetailsDtoOut>;
        }));
    }

    protected processGetAdvertiseDetails(response: HttpResponseBase): Observable<ApiAdvertiseDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiAdvertiseDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllAdvertisements(body: ApiAdvertisementSearchInput | undefined): Observable<ApiAllAdstOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAllAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvertisements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvertisements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiAllAdstOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiAllAdstOut>;
        }));
    }

    protected processGetAllAdvertisements(response: HttpResponseBase): Observable<ApiAllAdstOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiAllAdstOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFavoriteApi(body: ApiCreateFavoritetDto | undefined): Observable<ApiCreateFavoritetOut> {
        let url_ = this.baseUrl + "/api/Advertisement/CreateFavoriteApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFavoriteApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFavoriteApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateFavoritetOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateFavoritetOut>;
        }));
    }

    protected processCreateFavoriteApi(response: HttpResponseBase): Observable<ApiCreateFavoritetOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateFavoritetOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFavoritePost(body: number | undefined): Observable<DeleteFavoriteOutput> {
        let url_ = this.baseUrl + "/api/Advertisement/DeleteFavorite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFavoritePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFavoritePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteFavoriteOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteFavoriteOutput>;
        }));
    }

    protected processDeleteFavoritePost(response: HttpResponseBase): Observable<DeleteFavoriteOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteFavoriteOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllFavoritesForUser(body: ApiFavoriteInput | undefined): Observable<ApiFavoriteOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAllFavoritesForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFavoritesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFavoritesForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiFavoriteOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiFavoriteOut>;
        }));
    }

    protected processGetAllFavoritesForUser(response: HttpResponseBase): Observable<ApiFavoriteOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiFavoriteOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createViewApi(body: ApiCreateViewDto | undefined): Observable<ApiCreateViewOut> {
        let url_ = this.baseUrl + "/api/Advertisement/CreateViewApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateViewApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateViewApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateViewOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateViewOut>;
        }));
    }

    protected processCreateViewApi(response: HttpResponseBase): Observable<ApiCreateViewOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateViewOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getViewsForAdvertisementApi(body: ApiViewInput | undefined): Observable<ApiViewOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetViewsForAdvertisementApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewsForAdvertisementApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewsForAdvertisementApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiViewOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiViewOut>;
        }));
    }

    protected processGetViewsForAdvertisementApi(response: HttpResponseBase): Observable<ApiViewOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiViewOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getViewsForChartApi(body: ApiViewForChartInput | undefined): Observable<ApiViewForChartOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetViewsForChartApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewsForChartApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewsForChartApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiViewForChartOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiViewForChartOut>;
        }));
    }

    protected processGetViewsForChartApi(response: HttpResponseBase): Observable<ApiViewForChartOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiViewForChartOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllAdsByUserIdApi(body: ApiAdvertisementForUserInput | undefined): Observable<ApiUserAdsOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAllAdsByUserIdApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdsByUserIdApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdsByUserIdApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUserAdsOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUserAdsOut>;
        }));
    }

    protected processGetAllAdsByUserIdApi(response: HttpResponseBase): Observable<ApiUserAdsOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUserAdsOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdsPointsByUserIdApi(body: ApiAdvertisementForUserInput | undefined): Observable<ApiAdsPointsOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdsPointsByUserIdApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsPointsByUserIdApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsPointsByUserIdApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiAdsPointsOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiAdsPointsOut>;
        }));
    }

    protected processGetAdsPointsByUserIdApi(response: HttpResponseBase): Observable<ApiAdsPointsOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiAdsPointsOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAdById(body: number | undefined): Observable<DeleteAdOutput> {
        let url_ = this.baseUrl + "/api/Advertisement/DeleteAdById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteAdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteAdOutput>;
        }));
    }

    protected processDeleteAdById(response: HttpResponseBase): Observable<DeleteAdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteAdOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkStatus(body: number | undefined): Observable<CheckStatusOutput> {
        let url_ = this.baseUrl + "/api/Advertisement/CheckStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckStatusOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckStatusOutput>;
        }));
    }

    protected processCheckStatus(response: HttpResponseBase): Observable<CheckStatusOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckStatusOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeActiveStatus(body: number | undefined): Observable<ChangeAdStatusOutput> {
        let url_ = this.baseUrl + "/api/Advertisement/ChangeActiveStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeActiveStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeActiveStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangeAdStatusOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangeAdStatusOutput>;
        }));
    }

    protected processChangeActiveStatus(response: HttpResponseBase): Observable<ChangeAdStatusOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeAdStatusOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearAllByUserId(body: ApiAdvertisementForUserInput | undefined): Observable<DeleteAdOutput> {
        let url_ = this.baseUrl + "/api/Advertisement/ClearAllByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteAdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteAdOutput>;
        }));
    }

    protected processClearAllByUserId(response: HttpResponseBase): Observable<DeleteAdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteAdOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchAdvertisements(body: ApiAdvertisementSearchInput | undefined): Observable<ApiAllAdstOut> {
        let url_ = this.baseUrl + "/api/Advertisement/SearchAdvertisements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAdvertisements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAdvertisements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiAllAdstOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiAllAdstOut>;
        }));
    }

    protected processSearchAdvertisements(response: HttpResponseBase): Observable<ApiAllAdstOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiAllAdstOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdvertiseDetailsForMap(body: ApiAdvertisesInput | undefined): Observable<ApiAdvertiseDetailsMapDtoOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetAdvertiseDetailsForMap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertiseDetailsForMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertiseDetailsForMap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiAdvertiseDetailsMapDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiAdvertiseDetailsMapDtoOut>;
        }));
    }

    protected processGetAdvertiseDetailsForMap(response: HttpResponseBase): Observable<ApiAdvertiseDetailsMapDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiAdvertiseDetailsMapDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    placeDurationToAds(body: PlaceAdsDurationInput | undefined): Observable<ApiPlaceDurationOut> {
        let url_ = this.baseUrl + "/api/Advertisement/PlaceDurationToAds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlaceDurationToAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlaceDurationToAds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiPlaceDurationOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiPlaceDurationOut>;
        }));
    }

    protected processPlaceDurationToAds(response: HttpResponseBase): Observable<ApiPlaceDurationOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiPlaceDurationOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLastAdvertiseId(): Observable<LastAdvertiseInsertedOut> {
        let url_ = this.baseUrl + "/api/Advertisement/GetLastAdvertiseId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastAdvertiseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastAdvertiseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LastAdvertiseInsertedOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LastAdvertiseInsertedOut>;
        }));
    }

    protected processGetLastAdvertiseId(response: HttpResponseBase): Observable<LastAdvertiseInsertedOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LastAdvertiseInsertedOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetAdvertisementInput | undefined): Observable<AdvertisementDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<AdvertisementDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: AdvertisementDto | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param agreementStatus (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, agreementStatus: AgreementStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAdvertisementOutput> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (agreementStatus === null)
            throw new Error("The parameter 'agreementStatus' cannot be null.");
        else if (agreementStatus !== undefined)
            url_ += "AgreementStatus=" + encodeURIComponent("" + agreementStatus) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdvertisementOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdvertisementOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAdvertisementOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdvertisementOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param brokerID (optional) 
     * @param seekerID (optional) 
     * @param ownerID (optional) 
     * @param companyID (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAdsByUserId(brokerID: number | undefined, seekerID: number | undefined, ownerID: number | undefined, companyID: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAdvertisementOutput> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetAllAdsByUserId?";
        if (brokerID === null)
            throw new Error("The parameter 'brokerID' cannot be null.");
        else if (brokerID !== undefined)
            url_ += "BrokerID=" + encodeURIComponent("" + brokerID) + "&";
        if (seekerID === null)
            throw new Error("The parameter 'seekerID' cannot be null.");
        else if (seekerID !== undefined)
            url_ += "SeekerID=" + encodeURIComponent("" + seekerID) + "&";
        if (ownerID === null)
            throw new Error("The parameter 'ownerID' cannot be null.");
        else if (ownerID !== undefined)
            url_ += "OwnerID=" + encodeURIComponent("" + ownerID) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdvertisementOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdvertisementOutput>;
        }));
    }

    protected processGetAllAdsByUserId(response: HttpResponseBase): Observable<GetAdvertisementOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdvertisementOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFavorite(body: AdFavoriteDto | undefined): Observable<AdFavoriteDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/CreateFavorite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFavorite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFavorite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdFavoriteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdFavoriteDto>;
        }));
    }

    protected processCreateFavorite(response: HttpResponseBase): Observable<AdFavoriteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdFavoriteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param favoriteId (optional) 
     * @return Success
     */
    deleteFavoriteDelete(favoriteId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/DeleteFavorite?";
        if (favoriteId === null)
            throw new Error("The parameter 'favoriteId' cannot be null.");
        else if (favoriteId !== undefined)
            url_ += "favoriteId=" + encodeURIComponent("" + favoriteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFavoriteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFavoriteDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFavoriteDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getFavoritesForUser(userId: number | undefined): Observable<GetFavoriteOutput> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetFavoritesForUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavoritesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavoritesForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFavoriteOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFavoriteOutput>;
        }));
    }

    protected processGetFavoritesForUser(response: HttpResponseBase): Observable<GetFavoriteOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFavoriteOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createView(body: AdViewDto | undefined): Observable<AdViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/CreateView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdViewDto>;
        }));
    }

    protected processCreateView(response: HttpResponseBase): Observable<AdViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param advertisementId (optional) 
     * @return Success
     */
    getViewsForAdvertisement(advertisementId: number | undefined): Observable<GetViewOutput> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetViewsForAdvertisement?";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "advertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewsForAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewsForAdvertisement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetViewOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetViewOutput>;
        }));
    }

    protected processGetViewsForAdvertisement(response: HttpResponseBase): Observable<GetViewOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetViewOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param advertiseId (optional) 
     * @return Success
     */
    changeStatus(advertiseId: number | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/ChangeStatus?";
        if (advertiseId === null)
            throw new Error("The parameter 'advertiseId' cannot be null.");
        else if (advertiseId !== undefined)
            url_ += "advertiseId=" + encodeURIComponent("" + advertiseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementDto>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param advertiseId (optional) 
     * @return Success
     */
    checkAdvertisementStatus(advertiseId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/CheckAdvertisementStatus?";
        if (advertiseId === null)
            throw new Error("The parameter 'advertiseId' cannot be null.");
        else if (advertiseId !== undefined)
            url_ += "advertiseId=" + encodeURIComponent("" + advertiseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAdvertisementStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAdvertisementStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckAdvertisementStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param brokerID (optional) 
     * @param seekerID (optional) 
     * @param ownerID (optional) 
     * @param companyID (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    deleteAllByUserId(brokerID: number | undefined, seekerID: number | undefined, ownerID: number | undefined, companyID: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/DeleteAllByUserId?";
        if (brokerID === null)
            throw new Error("The parameter 'brokerID' cannot be null.");
        else if (brokerID !== undefined)
            url_ += "BrokerID=" + encodeURIComponent("" + brokerID) + "&";
        if (seekerID === null)
            throw new Error("The parameter 'seekerID' cannot be null.");
        else if (seekerID !== undefined)
            url_ += "SeekerID=" + encodeURIComponent("" + seekerID) + "&";
        if (ownerID === null)
            throw new Error("The parameter 'ownerID' cannot be null.");
        else if (ownerID !== undefined)
            url_ += "OwnerID=" + encodeURIComponent("" + ownerID) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllByUserId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchForApi(body: GetAdvertisementSearchInput | undefined): Observable<GetAdvertisementOutput> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/SearchForApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchForApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchForApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdvertisementOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdvertisementOutput>;
        }));
    }

    protected processSearchForApi(response: HttpResponseBase): Observable<GetAdvertisementOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdvertisementOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLastAdvertiseInsertedToDB(): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/services/app/Advertisement/GetLastAdvertiseInsertedToDB";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastAdvertiseInsertedToDB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastAdvertiseInsertedToDB(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementDto>;
        }));
    }

    protected processGetLastAdvertiseInsertedToDB(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdvertisementBookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAdvertisementBooking(body: ApiCreateAdvertisementBookingDto | undefined): Observable<ApiCreateAdvertisementBookingOut> {
        let url_ = this.baseUrl + "/api/AdvertisementBooking/CreateAdvertisementBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdvertisementBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdvertisementBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateAdvertisementBookingOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateAdvertisementBookingOut>;
        }));
    }

    protected processCreateAdvertisementBooking(response: HttpResponseBase): Observable<ApiCreateAdvertisementBookingOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateAdvertisementBookingOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAdvertisementBooking(body: ApiUpdateAdvertisementBookingDto | undefined): Observable<ApiUpdateAdvertisementBookingOut> {
        let url_ = this.baseUrl + "/api/AdvertisementBooking/UpdateAdvertisementBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdvertisementBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdvertisementBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUpdateAdvertisementBookingOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUpdateAdvertisementBookingOut>;
        }));
    }

    protected processUpdateAdvertisementBooking(response: HttpResponseBase): Observable<ApiUpdateAdvertisementBookingOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUpdateAdvertisementBookingOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAdvertisementBooking(body: ApiDeleteAdvertisementBookingDto | undefined): Observable<ApiDeleteAdvertisementBookingOut> {
        let url_ = this.baseUrl + "/api/AdvertisementBooking/DeleteAdvertisementBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdvertisementBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdvertisementBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiDeleteAdvertisementBookingOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiDeleteAdvertisementBookingOut>;
        }));
    }

    protected processDeleteAdvertisementBooking(response: HttpResponseBase): Observable<ApiDeleteAdvertisementBookingOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiDeleteAdvertisementBookingOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: AdvertisementBookingDto | undefined): Observable<AdvertisementBookingDto> {
        let url_ = this.baseUrl + "/api/services/app/AdvertisementBooking/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementBookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementBookingDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<AdvertisementBookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementBookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdvertisementBooking/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AdvertisementBookingDto> {
        let url_ = this.baseUrl + "/api/services/app/AdvertisementBooking/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementBookingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementBookingDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AdvertisementBookingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementBookingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param advertisementId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, advertisementId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdvertisementBookingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdvertisementBooking/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (advertisementId === null)
            throw new Error("The parameter 'advertisementId' cannot be null.");
        else if (advertisementId !== undefined)
            url_ += "AdvertisementId=" + encodeURIComponent("" + advertisementId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdvertisementBookingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdvertisementBookingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdvertisementBookingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementBookingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BrokerPersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBrokerPerson(body: ApiCreateBrokerPersonDto | undefined): Observable<ApiCreateBrokerPersonOut> {
        let url_ = this.baseUrl + "/api/BrokerPerson/CreateBrokerPerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrokerPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrokerPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateBrokerPersonOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateBrokerPersonOut>;
        }));
    }

    protected processCreateBrokerPerson(response: HttpResponseBase): Observable<ApiCreateBrokerPersonOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateBrokerPersonOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getBrokerPersonDetails(userId: number | undefined): Observable<ApiBrokerPersonDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/BrokerPerson/GetBrokerPersonDetails?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrokerPersonDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrokerPersonDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiBrokerPersonDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiBrokerPersonDetailsDtoOut>;
        }));
    }

    protected processGetBrokerPersonDetails(response: HttpResponseBase): Observable<ApiBrokerPersonDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiBrokerPersonDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrokerPerson(body: ApiUpdateBrokerPersonDto | undefined): Observable<ApiUpdateBrokerPersonOut> {
        let url_ = this.baseUrl + "/api/BrokerPerson/UpdateBrokerPerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrokerPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrokerPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUpdateBrokerPersonOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUpdateBrokerPersonOut>;
        }));
    }

    protected processUpdateBrokerPerson(response: HttpResponseBase): Observable<ApiUpdateBrokerPersonOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUpdateBrokerPersonOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetBrokerPersonInput | undefined): Observable<BrokerPersonDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrokerPersonDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrokerPersonDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<BrokerPersonDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerPersonDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: BrokerPersonDto | undefined): Observable<BrokerPersonDto> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrokerPersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrokerPersonDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<BrokerPersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerPersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<BrokerPersonDto> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrokerPersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrokerPersonDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BrokerPersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerPersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByUserId(id: number | undefined): Observable<BrokerPersonDto> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/GetByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrokerPersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrokerPersonDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<BrokerPersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerPersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetBrokerPersonOutput> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBrokerPersonOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBrokerPersonOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetBrokerPersonOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBrokerPersonOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrokerPersonFromMobile(body: BrokerPersonDto | undefined): Observable<BrokerPersonDto> {
        let url_ = this.baseUrl + "/api/services/app/BrokerPerson/UpdateBrokerPersonFromMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrokerPersonFromMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrokerPersonFromMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrokerPersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrokerPersonDto>;
        }));
    }

    protected processUpdateBrokerPersonFromMobile(response: HttpResponseBase): Observable<BrokerPersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerPersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetCityInput | undefined): Observable<CityDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/City/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<CityDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: CityDto | undefined): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/services/app/City/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/services/app/City/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param governorateId (optional) 
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(governorateId: number | undefined, name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/City/GetAll?";
        if (governorateId === null)
            throw new Error("The parameter 'governorateId' cannot be null.");
        else if (governorateId !== undefined)
            url_ += "GovernorateId=" + encodeURIComponent("" + governorateId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/City/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isEmailOrPhoneExist(body: ApiCommonyDto | undefined): Observable<GetIsEmailExist> {
        let url_ = this.baseUrl + "/api/Common/IsEmailOrPhoneExist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsEmailOrPhoneExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsEmailOrPhoneExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIsEmailExist>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIsEmailExist>;
        }));
    }

    protected processIsEmailOrPhoneExist(response: HttpResponseBase): Observable<GetIsEmailExist> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIsEmailExist.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllCountries(body: GetAllCountriesInput | undefined): Observable<GetAllCountriesOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCountriesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCountriesOutput>;
        }));
    }

    protected processGetAllCountries(response: HttpResponseBase): Observable<GetAllCountriesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCountriesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllGovernorates(body: GetAllGovernoratesInput | undefined): Observable<GetAllGovernoratesOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllGovernorates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGovernorates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGovernorates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllGovernoratesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllGovernoratesOutput>;
        }));
    }

    protected processGetAllGovernorates(response: HttpResponseBase): Observable<GetAllGovernoratesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllGovernoratesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllCities(body: GetAllCitiesInput | undefined): Observable<GetAllCitiesOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllCities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCitiesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCitiesOutput>;
        }));
    }

    protected processGetAllCities(response: HttpResponseBase): Observable<GetAllCitiesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCitiesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDefinitions(body: GetAllDefinitionsInput | undefined): Observable<GetAllDefinitionsOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllDefinitionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllDefinitionsOutput>;
        }));
    }

    protected processGetAllDefinitions(response: HttpResponseBase): Observable<GetAllDefinitionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDefinitionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllSponsors(body: GetAllSponsorsInput | undefined): Observable<GetAllSponsorsOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllSponsors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSponsors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSponsors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllSponsorsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllSponsorsOutput>;
        }));
    }

    protected processGetAllSponsors(response: HttpResponseBase): Observable<GetAllSponsorsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllSponsorsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDurations(body: GetAllDurationsInput | undefined): Observable<GetAllDurationsOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllDurations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDurations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllDurationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllDurationsOutput>;
        }));
    }

    protected processGetAllDurations(response: HttpResponseBase): Observable<GetAllDurationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDurationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountApi(body: ApiDeleteAccountDto | undefined): Observable<ApiDeleteAccountOut> {
        let url_ = this.baseUrl + "/api/Common/DeleteAccountApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiDeleteAccountOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiDeleteAccountOut>;
        }));
    }

    protected processDeleteAccountApi(response: HttpResponseBase): Observable<ApiDeleteAccountOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiDeleteAccountOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPassword(body: ApiChangePasswordDto | undefined): Observable<ApiChangePasswordOut> {
        let url_ = this.baseUrl + "/api/Common/UpdateUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiChangePasswordOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiChangePasswordOut>;
        }));
    }

    protected processUpdateUserPassword(response: HttpResponseBase): Observable<ApiChangePasswordOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiChangePasswordOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllSocialContacts(body: GetAllSocialContactsInput | undefined): Observable<GetAllSocialContactsOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllSocialContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSocialContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSocialContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllSocialContactsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllSocialContactsOutput>;
        }));
    }

    protected processGetAllSocialContacts(response: HttpResponseBase): Observable<GetAllSocialContactsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllSocialContactsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDiscountPrecentageAndFixedAmount(body: GetDiscontCodeInput | undefined): Observable<GetDiscontCodeOutput> {
        let url_ = this.baseUrl + "/api/Common/GetDiscountPrecentageAndFixedAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiscountPrecentageAndFixedAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiscountPrecentageAndFixedAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDiscontCodeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDiscontCodeOutput>;
        }));
    }

    protected processGetDiscountPrecentageAndFixedAmount(response: HttpResponseBase): Observable<GetDiscontCodeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDiscontCodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllPackages(body: GetAllPackagesInput | undefined): Observable<GetAllPackagesOutput> {
        let url_ = this.baseUrl + "/api/Common/GetAllPackages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPackages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPackagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPackagesOutput>;
        }));
    }

    protected processGetAllPackages(response: HttpResponseBase): Observable<GetAllPackagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPackagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllNotificationsForUserApi(body: ApiNotificationsForUserInput | undefined): Observable<ApiUserNotificationsOut> {
        let url_ = this.baseUrl + "/api/Common/GetAllNotificationsForUserApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotificationsForUserApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotificationsForUserApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUserNotificationsOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUserNotificationsOut>;
        }));
    }

    protected processGetAllNotificationsForUserApi(response: HttpResponseBase): Observable<ApiUserNotificationsOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUserNotificationsOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCount(): Observable<CountDto> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountDto>;
        }));
    }

    protected processGetCount(response: HttpResponseBase): Observable<CountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCompany(body: ApiCreateCompanyDto | undefined): Observable<ApiCreateCompanyOut> {
        let url_ = this.baseUrl + "/api/Company/CreateCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateCompanyOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateCompanyOut>;
        }));
    }

    protected processCreateCompany(response: HttpResponseBase): Observable<ApiCreateCompanyOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateCompanyOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getCompanyDetails(userId: number | undefined): Observable<ApiCompanyDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/Company/GetCompanyDetails?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCompanyDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCompanyDetailsDtoOut>;
        }));
    }

    protected processGetCompanyDetails(response: HttpResponseBase): Observable<ApiCompanyDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCompanyDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllCompanies(body: ApiCompanyInput | undefined): Observable<ApiCompanyiesOut> {
        let url_ = this.baseUrl + "/api/Company/GetAllCompanies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCompanyiesOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCompanyiesOut>;
        }));
    }

    protected processGetAllCompanies(response: HttpResponseBase): Observable<ApiCompanyiesOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCompanyiesOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompany(body: ApiUpdateCompanyDto | undefined): Observable<ApiUpdateCompanyOut> {
        let url_ = this.baseUrl + "/api/Company/UpdateCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUpdateCompanyOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUpdateCompanyOut>;
        }));
    }

    protected processUpdateCompany(response: HttpResponseBase): Observable<ApiUpdateCompanyOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUpdateCompanyOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getCompanyPackageDetailsApi(userId: number | undefined): Observable<ApiCompanyPackageDtoOut> {
        let url_ = this.baseUrl + "/api/Company/GetCompanyPackageDetailsApi?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyPackageDetailsApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyPackageDetailsApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCompanyPackageDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCompanyPackageDtoOut>;
        }));
    }

    protected processGetCompanyPackageDetailsApi(response: HttpResponseBase): Observable<ApiCompanyPackageDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCompanyPackageDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetCompanyInput | undefined): Observable<CompanyDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<CompanyDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: CompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByUserId(id: number | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param isSponsor (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, isSponsor: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetCompanyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isSponsor === null)
            throw new Error("The parameter 'isSponsor' cannot be null.");
        else if (isSponsor !== undefined)
            url_ += "IsSponsor=" + encodeURIComponent("" + isSponsor) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCompanyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCompanyOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetCompanyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCompanyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompanyFromMobile(body: CompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateCompanyFromMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompanyFromMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompanyFromMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processUpdateCompanyFromMobile(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanyPackageTransactionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: CompanyPackageTransactionDto | undefined): Observable<CompanyPackageTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyPackageTransaction/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyPackageTransactionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyPackageTransactionDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<CompanyPackageTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyPackageTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyPackageTransaction/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CompanyPackageTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyPackageTransaction/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyPackageTransactionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyPackageTransactionDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CompanyPackageTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyPackageTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param companyId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CompanyPackageTransactionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyPackageTransaction/GetAll?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyPackageTransactionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyPackageTransactionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyPackageTransactionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyPackageTransactionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactUsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContactUs(body: ApiCreateContactUsDto | undefined): Observable<ApiCreateContactUsOut> {
        let url_ = this.baseUrl + "/api/ContactUs/CreateContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateContactUsOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateContactUsOut>;
        }));
    }

    protected processCreateContactUs(response: HttpResponseBase): Observable<ApiCreateContactUsOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateContactUsOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetContactUsInput | undefined): Observable<ContactUsDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactUs/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactUsDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactUsDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<ContactUsDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: ContactUsDto | undefined): Observable<ContactUsDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactUs/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactUsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactUsDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<ContactUsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactUs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ContactUsDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactUs/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactUsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactUsDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ContactUsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param emailAddress (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(emailAddress: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContactUsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactUs/GetAll?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactUsDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactUsDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContactUsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetCountriesInput | undefined): Observable<CountryDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<CountryDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: CountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetCountriesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountriesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountriesOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetCountriesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountriesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetDefinitionsInput | undefined): Observable<DefinitionDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Definition/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DefinitionDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DefinitionDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<DefinitionDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefinitionDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: DefinitionDto | undefined): Observable<DefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/Definition/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DefinitionDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<DefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefinitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Definition/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/Definition/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DefinitionDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefinitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param enumCategory (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, enumCategory: DefinitionTypes | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetDefinitionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Definition/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (enumCategory === null)
            throw new Error("The parameter 'enumCategory' cannot be null.");
        else if (enumCategory !== undefined)
            url_ += "EnumCategory=" + encodeURIComponent("" + enumCategory) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefinitionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefinitionsOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetDefinitionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefinitionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DiscountCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetDiscountCodesInput | undefined): Observable<DiscountCodeDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountCodeDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountCodeDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<DiscountCodeDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountCodeDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: DiscountCodeDto | undefined): Observable<DiscountCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountCodeDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<DiscountCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DiscountCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountCodeDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DiscountCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<DiscountCodeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountCodeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountCodeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DiscountCodeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountCodeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getByCode(code: string | undefined): Observable<DiscountCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/DiscountCode/GetByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountCodeDto>;
        }));
    }

    protected processGetByCode(response: HttpResponseBase): Observable<DiscountCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetDurationInput | undefined): Observable<DurationDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Duration/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DurationDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DurationDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<DurationDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DurationDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: DurationDto | undefined): Observable<DurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Duration/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DurationDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<DurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Duration/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Duration/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DurationDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param type (optional) 
     * @param isPublish (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(type: BuildingType | undefined, isPublish: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DurationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Duration/GetAll?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (isPublish === null)
            throw new Error("The parameter 'isPublish' cannot be null.");
        else if (isPublish !== undefined)
            url_ += "IsPublish=" + encodeURIComponent("" + isPublish) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DurationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DurationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DurationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DurationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GovernorateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetGovernoratesInput | undefined): Observable<GovernorateDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Governorate/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<GovernorateDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GovernorateDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: GovernorateDto | undefined): Observable<GovernorateDto> {
        let url_ = this.baseUrl + "/api/services/app/Governorate/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<GovernorateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GovernorateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Governorate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<GovernorateDto> {
        let url_ = this.baseUrl + "/api/services/app/Governorate/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<GovernorateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GovernorateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param countryId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, countryId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetGovernoratesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Governorate/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGovernoratesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGovernoratesOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetGovernoratesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGovernoratesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param userId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, userId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NotificationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NotificationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<NotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateNotificationsDto | undefined): Observable<NotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    markAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/MarkAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NotificationDto | undefined): Observable<NotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getById(notificationId: number): Observable<Notification> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetById?";
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined and cannot be null.");
        else
            url_ += "NotificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Notification>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Notification>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Notification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllNotificationsByUserId(userId: number | undefined): Observable<GetNotificationListOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllNotificationsByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotificationsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotificationsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationListOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationListOutput>;
        }));
    }

    protected processGetAllNotificationsByUserId(response: HttpResponseBase): Observable<GetNotificationListOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationListOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OwnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOwner(body: ApiCreateOwnerDto | undefined): Observable<ApiCreateOwnerOut> {
        let url_ = this.baseUrl + "/api/Owner/CreateOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateOwnerOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateOwnerOut>;
        }));
    }

    protected processCreateOwner(response: HttpResponseBase): Observable<ApiCreateOwnerOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateOwnerOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getOwnerDetails(userId: number | undefined): Observable<ApiOwnerDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/Owner/GetOwnerDetails?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiOwnerDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiOwnerDetailsDtoOut>;
        }));
    }

    protected processGetOwnerDetails(response: HttpResponseBase): Observable<ApiOwnerDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiOwnerDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOwner(body: ApiUpdateOwnerDto | undefined): Observable<ApiUpdateOwnerOut> {
        let url_ = this.baseUrl + "/api/Owner/UpdateOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUpdateOwnerOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUpdateOwnerOut>;
        }));
    }

    protected processUpdateOwner(response: HttpResponseBase): Observable<ApiUpdateOwnerOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUpdateOwnerOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetOwnerInput | undefined): Observable<OwnerDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Owner/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<OwnerDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: OwnerDto | undefined): Observable<OwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owner/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<OwnerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<OwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owner/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OwnerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByUserId(id: number | undefined): Observable<OwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owner/GetByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<OwnerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetOwnerOutput> {
        let url_ = this.baseUrl + "/api/services/app/Owner/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetOwnerOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetOwnerOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetOwnerOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOwnerOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Owner/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOwnerFromMobile(body: OwnerDto | undefined): Observable<OwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owner/UpdateOwnerFromMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOwnerFromMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOwnerFromMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto>;
        }));
    }

    protected processUpdateOwnerFromMobile(response: HttpResponseBase): Observable<OwnerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetPackagesInput | undefined): Observable<PackageDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Package/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<PackageDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackageDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: PackageDto | undefined): Observable<PackageDto> {
        let url_ = this.baseUrl + "/api/services/app/Package/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<PackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Package/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PackageDto> {
        let url_ = this.baseUrl + "/api/services/app/Package/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetPackagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Package/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPackagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPackagesOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetPackagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPackagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    managaProject(body: ApiProjectDto | undefined): Observable<ApiProjectOut> {
        let url_ = this.baseUrl + "/api/Project/ManagaProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManagaProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManagaProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiProjectOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiProjectOut>;
        }));
    }

    protected processManagaProject(response: HttpResponseBase): Observable<ApiProjectOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiProjectOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getProjectDetails(body: ApiProjectDetailsInput | undefined): Observable<ApiProjectDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/Project/GetProjectDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiProjectDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiProjectDetailsDtoOut>;
        }));
    }

    protected processGetProjectDetails(response: HttpResponseBase): Observable<ApiProjectDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiProjectDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteProject(body: ApiDeleteProjectDto | undefined): Observable<ApiDeleteProjectOut> {
        let url_ = this.baseUrl + "/api/Project/DeleteProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiDeleteProjectOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiDeleteProjectOut>;
        }));
    }

    protected processDeleteProject(response: HttpResponseBase): Observable<ApiDeleteProjectOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiDeleteProjectOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllProjects(body: ApiProjectInput | undefined): Observable<GetAllProjectsOutput> {
        let url_ = this.baseUrl + "/api/Project/GetAllProjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllProjectsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllProjectsOutput>;
        }));
    }

    protected processGetAllProjects(response: HttpResponseBase): Observable<GetAllProjectsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllProjectsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    placeDurationToProjectAds(body: PlaceDurationInput | undefined): Observable<ApiPlaceDurationOut> {
        let url_ = this.baseUrl + "/api/Project/PlaceDurationToProjectAds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlaceDurationToProjectAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlaceDurationToProjectAds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiPlaceDurationOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiPlaceDurationOut>;
        }));
    }

    protected processPlaceDurationToProjectAds(response: HttpResponseBase): Observable<ApiPlaceDurationOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiPlaceDurationOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetProjectInput | undefined): Observable<ProjectDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Project/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<ProjectDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: ProjectDto | undefined): Observable<ProjectDto> {
        let url_ = this.baseUrl + "/api/services/app/Project/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<ProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ProjectDto> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param userId (optional) 
     * @param companyId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, userId: number | undefined, companyId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetProjectOutput> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProjectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProjectOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetProjectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProjectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetRatesInput | undefined): Observable<RateDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Rate/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RateDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RateDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<RateDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RateDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: RateDto | undefined): Observable<RateDto> {
        let url_ = this.baseUrl + "/api/services/app/Rate/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RateDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<RateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<RateDto> {
        let url_ = this.baseUrl + "/api/services/app/Rate/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RateDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetRatesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Rate/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRatesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRatesOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetRatesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRatesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RateUsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRate(body: ApiCreateRateDto | undefined): Observable<ApiCreateRateOut> {
        let url_ = this.baseUrl + "/api/RateUs/CreateRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateRateOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateRateOut>;
        }));
    }

    protected processCreateRate(response: HttpResponseBase): Observable<ApiCreateRateOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateRateOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllRates(body: GetAllRatesInput | undefined): Observable<GetAllRatesOutput> {
        let url_ = this.baseUrl + "/api/RateUs/GetAllRates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllRatesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllRatesOutput>;
        }));
    }

    protected processGetAllRates(response: HttpResponseBase): Observable<GetAllRatesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllRatesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeekerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSeeker(body: ApiCreateSeekerDto | undefined): Observable<ApiCreateSeekerOut> {
        let url_ = this.baseUrl + "/api/Seeker/CreateSeeker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSeeker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSeeker(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiCreateSeekerOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiCreateSeekerOut>;
        }));
    }

    protected processCreateSeeker(response: HttpResponseBase): Observable<ApiCreateSeekerOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCreateSeekerOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getSeekerDetails(userId: number | undefined): Observable<ApiSeekerDetailsDtoOut> {
        let url_ = this.baseUrl + "/api/Seeker/GetSeekerDetails?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSeekerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSeekerDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiSeekerDetailsDtoOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiSeekerDetailsDtoOut>;
        }));
    }

    protected processGetSeekerDetails(response: HttpResponseBase): Observable<ApiSeekerDetailsDtoOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiSeekerDetailsDtoOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSeeker(body: ApiUpdateSeekerDto | undefined): Observable<ApiUpdateSeekerOut> {
        let url_ = this.baseUrl + "/api/Seeker/UpdateSeeker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSeeker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSeeker(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiUpdateSeekerOut>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiUpdateSeekerOut>;
        }));
    }

    protected processUpdateSeeker(response: HttpResponseBase): Observable<ApiUpdateSeekerOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiUpdateSeekerOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetSeekerInput | undefined): Observable<SeekerDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeekerDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeekerDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<SeekerDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeekerDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: SeekerDto | undefined): Observable<SeekerDto> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeekerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeekerDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<SeekerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeekerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<SeekerDto> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeekerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeekerDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SeekerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeekerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByUserId(id: number | undefined): Observable<SeekerDto> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/GetByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeekerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeekerDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<SeekerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeekerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetSeekerOutput> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSeekerOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSeekerOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetSeekerOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSeekerOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSeekerFromMobile(body: SeekerDto | undefined): Observable<SeekerDto> {
        let url_ = this.baseUrl + "/api/services/app/Seeker/UpdateSeekerFromMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSeekerFromMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSeekerFromMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeekerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeekerDto>;
        }));
    }

    protected processUpdateSeekerFromMobile(response: HttpResponseBase): Observable<SeekerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeekerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param scope (optional) 
     * @return Success
     */
    getSettingDefinitions(scope: number | undefined): Observable<GetSettingDefinitionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetSettingDefinitions?";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "Scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSettingDefinitionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSettingDefinitionsOutput>;
        }));
    }

    protected processGetSettingDefinitions(response: HttpResponseBase): Observable<GetSettingDefinitionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSettingDefinitionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSettings(body: SaveSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Setting/SaveSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMailSetting(): Observable<MailData> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetMailSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailData>;
        }));
    }

    protected processGetMailSetting(response: HttpResponseBase): Observable<MailData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSettingValueByKey(key: string): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetSettingValueByKey?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingValueByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingValueByKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingValueByKey(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SocialContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetSocialContactsInput | undefined): Observable<SocialContactDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/SocialContact/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContactDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContactDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<SocialContactDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocialContactDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: SocialContactDto | undefined): Observable<SocialContactDto> {
        let url_ = this.baseUrl + "/api/services/app/SocialContact/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContactDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContactDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<SocialContactDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocialContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SocialContact/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<SocialContactDto> {
        let url_ = this.baseUrl + "/api/services/app/SocialContact/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContactDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContactDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SocialContactDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocialContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetSocialContactsOutput> {
        let url_ = this.baseUrl + "/api/services/app/SocialContact/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSocialContactsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSocialContactsOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetSocialContactsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSocialContactsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateInMobile(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateInMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateInMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateInMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticateInMobile(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPhoneNumberOtp(body: OtpRequestModel | undefined): Observable<OtpResponseModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/CheckPhoneNumberOtp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhoneNumberOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhoneNumberOtp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OtpResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OtpResponseModel>;
        }));
    }

    protected processCheckPhoneNumberOtp(response: HttpResponseBase): Observable<OtpResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OtpResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPaymentUrl(body: PaymentRequestModel | undefined): Observable<PaymentResponseModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetPaymentUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentResponseModel>;
        }));
    }

    protected processGetPaymentUrl(response: HttpResponseBase): Observable<PaymentResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param success (optional) 
     * @return Success
     */
    confirmPaymentAccept(success: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ConfirmPaymentAccept?";
        if (success === null)
            throw new Error("The parameter 'success' cannot be null.");
        else if (success !== undefined)
            url_ += "success=" + encodeURIComponent("" + success) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPaymentAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPaymentAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPaymentAccept(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    forgetPassword(userNameOrEmailAddress: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ForgetPassword?";
        if (userNameOrEmailAddress === undefined || userNameOrEmailAddress === null)
            throw new Error("The parameter 'userNameOrEmailAddress' must be defined and cannot be null.");
        else
            url_ += "UserNameOrEmailAddress=" + encodeURIComponent("" + userNameOrEmailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    upload(): Observable<void> {
        let url_ = this.baseUrl + "/api/Upload/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadMobile(file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Upload/UploadMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadMobile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    convertIFormFileToByteArray(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Upload/ConvertIFormFileToByteArray";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertIFormFileToByteArray(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertIFormFileToByteArray(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processConvertIFormFileToByteArray(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param width (optional) 
     * @param height (optional) 
     * @param file (optional) 
     * @return Success
     */
    resizeImage(width: number | undefined, height: number | undefined, file: FileParameter | undefined): Observable<Image> {
        let url_ = this.baseUrl + "/api/Upload/ResizeImage?";
        if (width === null)
            throw new Error("The parameter 'width' cannot be null.");
        else if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResizeImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResizeImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image>;
        }));
    }

    protected processResizeImage(response: HttpResponseBase): Observable<Image> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Image.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tag (optional) 
     * @param physicalDimension (optional) 
     * @param size (optional) 
     * @param width (optional) 
     * @param height (optional) 
     * @param horizontalResolution (optional) 
     * @param verticalResolution (optional) 
     * @param flags (optional) 
     * @param rawFormat (optional) 
     * @param pixelFormat (optional) 
     * @param propertyIdList (optional) 
     * @param propertyItems (optional) 
     * @param palette_Flags (optional) 
     * @param palette_Entries (optional) 
     * @param frameDimensionsList (optional) 
     * @param w (optional) 
     * @param h (optional) 
     * @return Success
     */
    resize(tag: any | undefined, physicalDimension: SizeF | undefined, size: Size | undefined, width: number | undefined, height: number | undefined, horizontalResolution: number | undefined, verticalResolution: number | undefined, flags: number | undefined, rawFormat: ImageFormat | undefined, pixelFormat: PixelFormat | undefined, propertyIdList: number[] | undefined, propertyItems: PropertyItem[] | undefined, palette_Flags: number | undefined, palette_Entries: Color[] | undefined, frameDimensionsList: string[] | undefined, w: number | undefined, h: number | undefined): Observable<Image> {
        let url_ = this.baseUrl + "/api/Upload/Resize?";
        if (tag === null)
            throw new Error("The parameter 'tag' cannot be null.");
        else if (tag !== undefined)
            url_ += "Tag=" + encodeURIComponent("" + tag) + "&";
        if (physicalDimension === null)
            throw new Error("The parameter 'physicalDimension' cannot be null.");
        else if (physicalDimension !== undefined)
            url_ += "PhysicalDimension=" + encodeURIComponent("" + physicalDimension) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (width === null)
            throw new Error("The parameter 'width' cannot be null.");
        else if (width !== undefined)
            url_ += "Width=" + encodeURIComponent("" + width) + "&";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (horizontalResolution === null)
            throw new Error("The parameter 'horizontalResolution' cannot be null.");
        else if (horizontalResolution !== undefined)
            url_ += "HorizontalResolution=" + encodeURIComponent("" + horizontalResolution) + "&";
        if (verticalResolution === null)
            throw new Error("The parameter 'verticalResolution' cannot be null.");
        else if (verticalResolution !== undefined)
            url_ += "VerticalResolution=" + encodeURIComponent("" + verticalResolution) + "&";
        if (flags === null)
            throw new Error("The parameter 'flags' cannot be null.");
        else if (flags !== undefined)
            url_ += "Flags=" + encodeURIComponent("" + flags) + "&";
        if (rawFormat === null)
            throw new Error("The parameter 'rawFormat' cannot be null.");
        else if (rawFormat !== undefined)
            url_ += "RawFormat=" + encodeURIComponent("" + rawFormat) + "&";
        if (pixelFormat === null)
            throw new Error("The parameter 'pixelFormat' cannot be null.");
        else if (pixelFormat !== undefined)
            url_ += "PixelFormat=" + encodeURIComponent("" + pixelFormat) + "&";
        if (propertyIdList === null)
            throw new Error("The parameter 'propertyIdList' cannot be null.");
        else if (propertyIdList !== undefined)
            propertyIdList && propertyIdList.forEach(item => { url_ += "PropertyIdList=" + encodeURIComponent("" + item) + "&"; });
        if (propertyItems === null)
            throw new Error("The parameter 'propertyItems' cannot be null.");
        else if (propertyItems !== undefined)
            propertyItems && propertyItems.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "PropertyItems[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (palette_Flags === null)
            throw new Error("The parameter 'palette_Flags' cannot be null.");
        else if (palette_Flags !== undefined)
            url_ += "Palette.Flags=" + encodeURIComponent("" + palette_Flags) + "&";
        if (palette_Entries === null)
            throw new Error("The parameter 'palette_Entries' cannot be null.");
        else if (palette_Entries !== undefined)
            palette_Entries && palette_Entries.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Palette.Entries[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (frameDimensionsList === null)
            throw new Error("The parameter 'frameDimensionsList' cannot be null.");
        else if (frameDimensionsList !== undefined)
            frameDimensionsList && frameDimensionsList.forEach(item => { url_ += "FrameDimensionsList=" + encodeURIComponent("" + item) + "&"; });
        if (w === null)
            throw new Error("The parameter 'w' cannot be null.");
        else if (w !== undefined)
            url_ += "w=" + encodeURIComponent("" + w) + "&";
        if (h === null)
            throw new Error("The parameter 'h' cannot be null.");
        else if (h !== undefined)
            url_ += "h=" + encodeURIComponent("" + h) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image>;
        }));
    }

    protected processResize(response: HttpResponseBase): Observable<Image> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Image.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetUsersInput | undefined): Observable<UserDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/User/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<UserDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePermissions(body: SaveUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/SavePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWithPermissionsById(id: number | undefined): Observable<GetUserWithPermissionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetWithPermissionsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWithPermissionsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWithPermissionsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserWithPermissionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserWithPermissionsOutput>;
        }));
    }

    protected processGetWithPermissionsById(response: HttpResponseBase): Observable<GetUserWithPermissionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserWithPermissionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearExplicitPermissions(body: Int64EntityDto | undefined): Observable<GetUserWithPermissionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/ClearExplicitPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearExplicitPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearExplicitPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserWithPermissionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserWithPermissionsOutput>;
        }));
    }

    protected processClearExplicitPermissions(response: HttpResponseBase): Observable<GetUserWithPermissionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserWithPermissionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPasswordForForget(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPasswordForForget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordForForget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordForForget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPasswordForForget(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    generateOtp(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/GenerateOtp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateOtp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateOtp(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param number (optional) 
     * @param msg (optional) 
     * @return Success
     */
    sendSMSOTP(number: string | undefined, msg: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/SendSMSOTP?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&";
        if (msg === null)
            throw new Error("The parameter 'msg' cannot be null.");
        else if (msg !== undefined)
            url_ += "msg=" + encodeURIComponent("" + msg) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSMSOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSMSOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSendSMSOTP(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgetPassword(body: ForgetPasswordDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/ForgetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: UserDeviceDto | undefined): Observable<UserDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDeviceDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<UserDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<UserDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDeviceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDeviceDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UserDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetUserDevicesOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserDevicesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserDevicesOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetUserDevicesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDevicesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkDevice(body: CheckDeviceInput | undefined): Observable<UserDevice> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/CheckDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDevice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDevice>;
        }));
    }

    protected processCheckDevice(response: HttpResponseBase): Observable<UserDevice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDevice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    check(body: CheckRegisteredDeviceInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/Check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheck(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPushNotification(body: SendPushNotificationInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/UserDevice/SendPushNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPushNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPushNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSendPushNotification(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isPaged(body: GetWalletsInput | undefined): Observable<WalletDtoDataTableOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/IsPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoDataTableOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoDataTableOutputDto>;
        }));
    }

    protected processIsPaged(response: HttpResponseBase): Observable<WalletDtoDataTableOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoDataTableOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body: WalletDto | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDto>;
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param companyId (optional) 
     * @param enumTransaction (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, companyId: number | undefined, enumTransaction: TransactionType | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetWalletsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (enumTransaction === null)
            throw new Error("The parameter 'enumTransaction' cannot be null.");
        else if (enumTransaction !== undefined)
            url_ += "EnumTransaction=" + encodeURIComponent("" + enumTransaction) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetWalletsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetWalletsOutput>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetWalletsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWalletsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AdFavoriteDto implements IAdFavoriteDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    advertisementId: number;
    advertisement: Advertisement;

    constructor(data?: IAdFavoriteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdFavoriteDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdFavoriteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdFavoriteDto {
        const json = this.toJSON();
        let result = new AdFavoriteDto();
        result.init(json);
        return result;
    }
}

export interface IAdFavoriteDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    advertisementId: number;
    advertisement: Advertisement;
}

export class AdView implements IAdView {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    deviceToken: string | undefined;
    userId: number;
    user: User;
    advertisementId: number;

    constructor(data?: IAdView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.deviceToken = _data["deviceToken"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): AdView {
        data = typeof data === 'object' ? data : {};
        let result = new AdView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deviceToken"] = this.deviceToken;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): AdView {
        const json = this.toJSON();
        let result = new AdView();
        result.init(json);
        return result;
    }
}

export interface IAdView {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    deviceToken: string | undefined;
    userId: number;
    user: User;
    advertisementId: number;
}

export class AdViewDto implements IAdViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    advertisementId: number;

    constructor(data?: IAdViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): AdViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): AdViewDto {
        const json = this.toJSON();
        let result = new AdViewDto();
        result.init(json);
        return result;
    }
}

export interface IAdViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    advertisementId: number;
}

export enum AdvertiseMakerType {
    _1 = 1,
    _2 = 2,
}

export class Advertisement implements IAdvertisement {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    city: City;
    governorateId: number | undefined;
    governorate: Governorate;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    dinning: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    durationId: number | undefined;
    duration: Duration;
    seekerId: number | undefined;
    seeker: Seeker;
    ownerId: number | undefined;
    owner: Owner;
    companyId: number | undefined;
    company: Company;
    brokerPersonId: number | undefined;
    brokerPerson: BrokerPerson;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    proximityToTheSea: ProximityToTheSeaType;
    officies: OfficiesType;
    airConditioner: boolean | undefined;
    diningRoom: boolean | undefined;
    rent: RentType;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookForChalet: Definition;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    points: number | undefined;
    views: AdView[] | undefined;
    photos: Photo[] | undefined;
    layouts: Layout[] | undefined;
    advertisementFacilites: AdvertisementFacility[] | undefined;
    advertisementBookingsList: AdvertisementBooking[] | undefined;
    projectId: number | undefined;
    project: Project;
    isEdited: boolean | undefined;

    constructor(data?: IAdvertisement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.city = _data["city"] ? City.fromJS(_data["city"]) : <any>undefined;
            this.governorateId = _data["governorateId"];
            this.governorate = _data["governorate"] ? Governorate.fromJS(_data["governorate"]) : <any>undefined;
            this.compound = _data["compound"];
            this.street = _data["street"];
            this.buildingNumber = _data["buildingNumber"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.floorsNumber = _data["floorsNumber"];
            this.area = _data["area"];
            this.buildingArea = _data["buildingArea"];
            this.chaletType = _data["chaletType"];
            this.agreementStatus = _data["agreementStatus"];
            this.buildingStatus = _data["buildingStatus"];
            this.landingStatus = _data["landingStatus"];
            this.usingFor = _data["usingFor"];
            this.streetWidth = _data["streetWidth"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.buildingDate = _data["buildingDate"] ? moment(_data["buildingDate"].toString()) : <any>undefined;
            this.rooms = _data["rooms"];
            this.dinning = _data["dinning"];
            this.reception = _data["reception"];
            this.balcony = _data["balcony"];
            this.kitchen = _data["kitchen"];
            this.toilet = _data["toilet"];
            this.numUnits = _data["numUnits"];
            this.numPartitions = _data["numPartitions"];
            this.officesNum = _data["officesNum"];
            this.officesFloors = _data["officesFloors"];
            this.decoration = _data["decoration"];
            this.document = _data["document"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"] ? Duration.fromJS(_data["duration"]) : <any>undefined;
            this.seekerId = _data["seekerId"];
            this.seeker = _data["seeker"] ? Seeker.fromJS(_data["seeker"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? Owner.fromJS(_data["owner"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.brokerPersonId = _data["brokerPersonId"];
            this.brokerPerson = _data["brokerPerson"] ? BrokerPerson.fromJS(_data["brokerPerson"]) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            this.description = _data["description"];
            this.featuredAd = _data["featuredAd"];
            this.price = _data["price"];
            this.paymentFacility = _data["paymentFacility"];
            this.mrMrs = _data["mrMrs"];
            this.advertiseMakerName = _data["advertiseMakerName"];
            this.advertiseMaker = _data["advertiseMaker"];
            this.mobileNumber = _data["mobileNumber"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.secondMobileNumber = _data["secondMobileNumber"];
            this.contactRegisterInTheAccount = _data["contactRegisterInTheAccount"];
            this.furnished = _data["furnished"];
            this.elevator = _data["elevator"];
            this.parking = _data["parking"];
            this.parkingSpace = _data["parkingSpace"];
            this.garden = _data["garden"];
            this.gardenArea = _data["gardenArea"];
            this.pool = _data["pool"];
            this.shop = _data["shop"];
            this.shopsNumber = _data["shopsNumber"];
            this.proximityToTheSea = _data["proximityToTheSea"];
            this.officies = _data["officies"];
            this.airConditioner = _data["airConditioner"];
            this.diningRoom = _data["diningRoom"];
            this.rent = _data["rent"];
            this.chaletRentType = _data["chaletRentType"];
            this.chaletRentValue = _data["chaletRentValue"];
            this.numOfMonths = _data["numOfMonths"];
            this.minTimeToBookForChaletId = _data["minTimeToBookForChaletId"];
            this.minTimeToBookForChalet = _data["minTimeToBookForChalet"] ? Definition.fromJS(_data["minTimeToBookForChalet"]) : <any>undefined;
            this.downPayment = _data["downPayment"];
            this.monthlyInstallment = _data["monthlyInstallment"];
            this.yearlyInstallment = _data["yearlyInstallment"];
            this.numOfYears = _data["numOfYears"];
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.points = _data["points"];
            if (Array.isArray(_data["views"])) {
                this.views = [] as any;
                for (let item of _data["views"])
                    this.views.push(AdView.fromJS(item));
            }
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(Photo.fromJS(item));
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts.push(Layout.fromJS(item));
            }
            if (Array.isArray(_data["advertisementFacilites"])) {
                this.advertisementFacilites = [] as any;
                for (let item of _data["advertisementFacilites"])
                    this.advertisementFacilites.push(AdvertisementFacility.fromJS(item));
            }
            if (Array.isArray(_data["advertisementBookingsList"])) {
                this.advertisementBookingsList = [] as any;
                for (let item of _data["advertisementBookingsList"])
                    this.advertisementBookingsList.push(AdvertisementBooking.fromJS(item));
            }
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.isEdited = _data["isEdited"];
        }
    }

    static fromJS(data: any): Advertisement {
        data = typeof data === 'object' ? data : {};
        let result = new Advertisement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["governorateId"] = this.governorateId;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["compound"] = this.compound;
        data["street"] = this.street;
        data["buildingNumber"] = this.buildingNumber;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["floorsNumber"] = this.floorsNumber;
        data["area"] = this.area;
        data["buildingArea"] = this.buildingArea;
        data["chaletType"] = this.chaletType;
        data["agreementStatus"] = this.agreementStatus;
        data["buildingStatus"] = this.buildingStatus;
        data["landingStatus"] = this.landingStatus;
        data["usingFor"] = this.usingFor;
        data["streetWidth"] = this.streetWidth;
        data["width"] = this.width;
        data["length"] = this.length;
        data["buildingDate"] = this.buildingDate ? this.buildingDate.toISOString() : <any>undefined;
        data["rooms"] = this.rooms;
        data["dinning"] = this.dinning;
        data["reception"] = this.reception;
        data["balcony"] = this.balcony;
        data["kitchen"] = this.kitchen;
        data["toilet"] = this.toilet;
        data["numUnits"] = this.numUnits;
        data["numPartitions"] = this.numPartitions;
        data["officesNum"] = this.officesNum;
        data["officesFloors"] = this.officesFloors;
        data["decoration"] = this.decoration;
        data["document"] = this.document;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["seekerId"] = this.seekerId;
        data["seeker"] = this.seeker ? this.seeker.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["brokerPersonId"] = this.brokerPersonId;
        data["brokerPerson"] = this.brokerPerson ? this.brokerPerson.toJSON() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        data["description"] = this.description;
        data["featuredAd"] = this.featuredAd;
        data["price"] = this.price;
        data["paymentFacility"] = this.paymentFacility;
        data["mrMrs"] = this.mrMrs;
        data["advertiseMakerName"] = this.advertiseMakerName;
        data["advertiseMaker"] = this.advertiseMaker;
        data["mobileNumber"] = this.mobileNumber;
        data["isWhatsApped"] = this.isWhatsApped;
        data["secondMobileNumber"] = this.secondMobileNumber;
        data["contactRegisterInTheAccount"] = this.contactRegisterInTheAccount;
        data["furnished"] = this.furnished;
        data["elevator"] = this.elevator;
        data["parking"] = this.parking;
        data["parkingSpace"] = this.parkingSpace;
        data["garden"] = this.garden;
        data["gardenArea"] = this.gardenArea;
        data["pool"] = this.pool;
        data["shop"] = this.shop;
        data["shopsNumber"] = this.shopsNumber;
        data["proximityToTheSea"] = this.proximityToTheSea;
        data["officies"] = this.officies;
        data["airConditioner"] = this.airConditioner;
        data["diningRoom"] = this.diningRoom;
        data["rent"] = this.rent;
        data["chaletRentType"] = this.chaletRentType;
        data["chaletRentValue"] = this.chaletRentValue;
        data["numOfMonths"] = this.numOfMonths;
        data["minTimeToBookForChaletId"] = this.minTimeToBookForChaletId;
        data["minTimeToBookForChalet"] = this.minTimeToBookForChalet ? this.minTimeToBookForChalet.toJSON() : <any>undefined;
        data["downPayment"] = this.downPayment;
        data["monthlyInstallment"] = this.monthlyInstallment;
        data["yearlyInstallment"] = this.yearlyInstallment;
        data["numOfYears"] = this.numOfYears;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["points"] = this.points;
        if (Array.isArray(this.views)) {
            data["views"] = [];
            for (let item of this.views)
                data["views"].push(item.toJSON());
        }
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        if (Array.isArray(this.advertisementFacilites)) {
            data["advertisementFacilites"] = [];
            for (let item of this.advertisementFacilites)
                data["advertisementFacilites"].push(item.toJSON());
        }
        if (Array.isArray(this.advertisementBookingsList)) {
            data["advertisementBookingsList"] = [];
            for (let item of this.advertisementBookingsList)
                data["advertisementBookingsList"].push(item.toJSON());
        }
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["isEdited"] = this.isEdited;
        return data;
    }

    clone(): Advertisement {
        const json = this.toJSON();
        let result = new Advertisement();
        result.init(json);
        return result;
    }
}

export interface IAdvertisement {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    city: City;
    governorateId: number | undefined;
    governorate: Governorate;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    dinning: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    durationId: number | undefined;
    duration: Duration;
    seekerId: number | undefined;
    seeker: Seeker;
    ownerId: number | undefined;
    owner: Owner;
    companyId: number | undefined;
    company: Company;
    brokerPersonId: number | undefined;
    brokerPerson: BrokerPerson;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    proximityToTheSea: ProximityToTheSeaType;
    officies: OfficiesType;
    airConditioner: boolean | undefined;
    diningRoom: boolean | undefined;
    rent: RentType;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookForChalet: Definition;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    points: number | undefined;
    views: AdView[] | undefined;
    photos: Photo[] | undefined;
    layouts: Layout[] | undefined;
    advertisementFacilites: AdvertisementFacility[] | undefined;
    advertisementBookingsList: AdvertisementBooking[] | undefined;
    projectId: number | undefined;
    project: Project;
    isEdited: boolean | undefined;
}

export class AdvertisementBooking implements IAdvertisementBooking {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bookingDate: moment.Moment;
    advertisementId: number;
    advertisement: Advertisement;

    constructor(data?: IAdvertisementBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.bookingDate = _data["bookingDate"] ? moment(_data["bookingDate"].toString()) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementBooking {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toISOString() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdvertisementBooking {
        const json = this.toJSON();
        let result = new AdvertisementBooking();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementBooking {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bookingDate: moment.Moment;
    advertisementId: number;
    advertisement: Advertisement;
}

export class AdvertisementBookingDto implements IAdvertisementBookingDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bookingDate: moment.Moment;
    advertisementId: number;
    advertisement: AdvertisementDto;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IAdvertisementBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.bookingDate = _data["bookingDate"] ? moment(_data["bookingDate"].toString()) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? AdvertisementDto.fromJS(_data["advertisement"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toISOString() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdvertisementBookingDto {
        const json = this.toJSON();
        let result = new AdvertisementBookingDto();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementBookingDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    bookingDate: moment.Moment;
    advertisementId: number;
    advertisement: AdvertisementDto;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class AdvertisementBookingDtoPagedResultDto implements IAdvertisementBookingDtoPagedResultDto {
    items: AdvertisementBookingDto[] | undefined;
    totalCount: number;

    constructor(data?: IAdvertisementBookingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdvertisementBookingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AdvertisementBookingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementBookingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AdvertisementBookingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdvertisementBookingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementBookingDtoPagedResultDto {
    items: AdvertisementBookingDto[] | undefined;
    totalCount: number;
}

export class AdvertisementDto implements IAdvertisementDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    city: CityDto;
    governorateId: number | undefined;
    governorate: GovernorateDto;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    duration: DurationDto;
    seekerId: number | undefined;
    seeker: SeekerDto;
    ownerId: number | undefined;
    owner: OwnerDto;
    companyId: number | undefined;
    company: CompanyDto;
    brokerPersonId: number | undefined;
    brokerPerson: BrokerPersonDto;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    proximityToTheSea: ProximityToTheSeaType;
    officies: OfficiesType;
    airConditioner: boolean | undefined;
    diningRoom: boolean | undefined;
    dinning: number | undefined;
    rent: RentType;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookForChalet: DefinitionDto;
    points: number | undefined;
    views: AdViewDto[] | undefined;
    advertisementFacilites: AdvertisementFacilityDto[] | undefined;
    photos: PhotoDto[] | undefined;
    layouts: LayoutDto[] | undefined;
    advertisementFacilitesList: number[] | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisementBookings: moment.Moment[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    projectId: number | undefined;
    isEdited: boolean | undefined;

    constructor(data?: IAdvertisementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.city = _data["city"] ? CityDto.fromJS(_data["city"]) : <any>undefined;
            this.governorateId = _data["governorateId"];
            this.governorate = _data["governorate"] ? GovernorateDto.fromJS(_data["governorate"]) : <any>undefined;
            this.compound = _data["compound"];
            this.street = _data["street"];
            this.buildingNumber = _data["buildingNumber"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.floorsNumber = _data["floorsNumber"];
            this.area = _data["area"];
            this.buildingArea = _data["buildingArea"];
            this.chaletType = _data["chaletType"];
            this.agreementStatus = _data["agreementStatus"];
            this.buildingStatus = _data["buildingStatus"];
            this.landingStatus = _data["landingStatus"];
            this.usingFor = _data["usingFor"];
            this.streetWidth = _data["streetWidth"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.buildingDate = _data["buildingDate"] ? moment(_data["buildingDate"].toString()) : <any>undefined;
            this.rooms = _data["rooms"];
            this.reception = _data["reception"];
            this.balcony = _data["balcony"];
            this.kitchen = _data["kitchen"];
            this.toilet = _data["toilet"];
            this.numUnits = _data["numUnits"];
            this.numPartitions = _data["numPartitions"];
            this.officesNum = _data["officesNum"];
            this.officesFloors = _data["officesFloors"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"] ? DurationDto.fromJS(_data["duration"]) : <any>undefined;
            this.seekerId = _data["seekerId"];
            this.seeker = _data["seeker"] ? SeekerDto.fromJS(_data["seeker"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? OwnerDto.fromJS(_data["owner"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.brokerPersonId = _data["brokerPersonId"];
            this.brokerPerson = _data["brokerPerson"] ? BrokerPersonDto.fromJS(_data["brokerPerson"]) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            this.description = _data["description"];
            this.featuredAd = _data["featuredAd"];
            this.price = _data["price"];
            this.paymentFacility = _data["paymentFacility"];
            this.mrMrs = _data["mrMrs"];
            this.advertiseMakerName = _data["advertiseMakerName"];
            this.advertiseMaker = _data["advertiseMaker"];
            this.mobileNumber = _data["mobileNumber"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.secondMobileNumber = _data["secondMobileNumber"];
            this.contactRegisterInTheAccount = _data["contactRegisterInTheAccount"];
            this.furnished = _data["furnished"];
            this.elevator = _data["elevator"];
            this.parking = _data["parking"];
            this.parkingSpace = _data["parkingSpace"];
            this.garden = _data["garden"];
            this.gardenArea = _data["gardenArea"];
            this.pool = _data["pool"];
            this.shop = _data["shop"];
            this.shopsNumber = _data["shopsNumber"];
            this.decoration = _data["decoration"];
            this.document = _data["document"];
            this.proximityToTheSea = _data["proximityToTheSea"];
            this.officies = _data["officies"];
            this.airConditioner = _data["airConditioner"];
            this.diningRoom = _data["diningRoom"];
            this.dinning = _data["dinning"];
            this.rent = _data["rent"];
            this.chaletRentType = _data["chaletRentType"];
            this.chaletRentValue = _data["chaletRentValue"];
            this.numOfMonths = _data["numOfMonths"];
            this.minTimeToBookForChaletId = _data["minTimeToBookForChaletId"];
            this.minTimeToBookForChalet = _data["minTimeToBookForChalet"] ? DefinitionDto.fromJS(_data["minTimeToBookForChalet"]) : <any>undefined;
            this.points = _data["points"];
            if (Array.isArray(_data["views"])) {
                this.views = [] as any;
                for (let item of _data["views"])
                    this.views.push(AdViewDto.fromJS(item));
            }
            if (Array.isArray(_data["advertisementFacilites"])) {
                this.advertisementFacilites = [] as any;
                for (let item of _data["advertisementFacilites"])
                    this.advertisementFacilites.push(AdvertisementFacilityDto.fromJS(item));
            }
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(PhotoDto.fromJS(item));
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts.push(LayoutDto.fromJS(item));
            }
            if (Array.isArray(_data["advertisementFacilitesList"])) {
                this.advertisementFacilitesList = [] as any;
                for (let item of _data["advertisementFacilitesList"])
                    this.advertisementFacilitesList.push(item);
            }
            if (Array.isArray(_data["photosList"])) {
                this.photosList = [] as any;
                for (let item of _data["photosList"])
                    this.photosList.push(item);
            }
            if (Array.isArray(_data["layoutsList"])) {
                this.layoutsList = [] as any;
                for (let item of _data["layoutsList"])
                    this.layoutsList.push(item);
            }
            if (Array.isArray(_data["advertisementBookings"])) {
                this.advertisementBookings = [] as any;
                for (let item of _data["advertisementBookings"])
                    this.advertisementBookings.push(moment(item));
            }
            this.downPayment = _data["downPayment"];
            this.monthlyInstallment = _data["monthlyInstallment"];
            this.yearlyInstallment = _data["yearlyInstallment"];
            this.numOfYears = _data["numOfYears"];
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
            this.isEdited = _data["isEdited"];
        }
    }

    static fromJS(data: any): AdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["governorateId"] = this.governorateId;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["compound"] = this.compound;
        data["street"] = this.street;
        data["buildingNumber"] = this.buildingNumber;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["floorsNumber"] = this.floorsNumber;
        data["area"] = this.area;
        data["buildingArea"] = this.buildingArea;
        data["chaletType"] = this.chaletType;
        data["agreementStatus"] = this.agreementStatus;
        data["buildingStatus"] = this.buildingStatus;
        data["landingStatus"] = this.landingStatus;
        data["usingFor"] = this.usingFor;
        data["streetWidth"] = this.streetWidth;
        data["width"] = this.width;
        data["length"] = this.length;
        data["buildingDate"] = this.buildingDate ? this.buildingDate.toISOString() : <any>undefined;
        data["rooms"] = this.rooms;
        data["reception"] = this.reception;
        data["balcony"] = this.balcony;
        data["kitchen"] = this.kitchen;
        data["toilet"] = this.toilet;
        data["numUnits"] = this.numUnits;
        data["numPartitions"] = this.numPartitions;
        data["officesNum"] = this.officesNum;
        data["officesFloors"] = this.officesFloors;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["seekerId"] = this.seekerId;
        data["seeker"] = this.seeker ? this.seeker.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["brokerPersonId"] = this.brokerPersonId;
        data["brokerPerson"] = this.brokerPerson ? this.brokerPerson.toJSON() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        data["description"] = this.description;
        data["featuredAd"] = this.featuredAd;
        data["price"] = this.price;
        data["paymentFacility"] = this.paymentFacility;
        data["mrMrs"] = this.mrMrs;
        data["advertiseMakerName"] = this.advertiseMakerName;
        data["advertiseMaker"] = this.advertiseMaker;
        data["mobileNumber"] = this.mobileNumber;
        data["isWhatsApped"] = this.isWhatsApped;
        data["secondMobileNumber"] = this.secondMobileNumber;
        data["contactRegisterInTheAccount"] = this.contactRegisterInTheAccount;
        data["furnished"] = this.furnished;
        data["elevator"] = this.elevator;
        data["parking"] = this.parking;
        data["parkingSpace"] = this.parkingSpace;
        data["garden"] = this.garden;
        data["gardenArea"] = this.gardenArea;
        data["pool"] = this.pool;
        data["shop"] = this.shop;
        data["shopsNumber"] = this.shopsNumber;
        data["decoration"] = this.decoration;
        data["document"] = this.document;
        data["proximityToTheSea"] = this.proximityToTheSea;
        data["officies"] = this.officies;
        data["airConditioner"] = this.airConditioner;
        data["diningRoom"] = this.diningRoom;
        data["dinning"] = this.dinning;
        data["rent"] = this.rent;
        data["chaletRentType"] = this.chaletRentType;
        data["chaletRentValue"] = this.chaletRentValue;
        data["numOfMonths"] = this.numOfMonths;
        data["minTimeToBookForChaletId"] = this.minTimeToBookForChaletId;
        data["minTimeToBookForChalet"] = this.minTimeToBookForChalet ? this.minTimeToBookForChalet.toJSON() : <any>undefined;
        data["points"] = this.points;
        if (Array.isArray(this.views)) {
            data["views"] = [];
            for (let item of this.views)
                data["views"].push(item.toJSON());
        }
        if (Array.isArray(this.advertisementFacilites)) {
            data["advertisementFacilites"] = [];
            for (let item of this.advertisementFacilites)
                data["advertisementFacilites"].push(item.toJSON());
        }
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        if (Array.isArray(this.advertisementFacilitesList)) {
            data["advertisementFacilitesList"] = [];
            for (let item of this.advertisementFacilitesList)
                data["advertisementFacilitesList"].push(item);
        }
        if (Array.isArray(this.photosList)) {
            data["photosList"] = [];
            for (let item of this.photosList)
                data["photosList"].push(item);
        }
        if (Array.isArray(this.layoutsList)) {
            data["layoutsList"] = [];
            for (let item of this.layoutsList)
                data["layoutsList"].push(item);
        }
        if (Array.isArray(this.advertisementBookings)) {
            data["advertisementBookings"] = [];
            for (let item of this.advertisementBookings)
                data["advertisementBookings"].push(item.toISOString());
        }
        data["downPayment"] = this.downPayment;
        data["monthlyInstallment"] = this.monthlyInstallment;
        data["yearlyInstallment"] = this.yearlyInstallment;
        data["numOfYears"] = this.numOfYears;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["isEdited"] = this.isEdited;
        return data;
    }

    clone(): AdvertisementDto {
        const json = this.toJSON();
        let result = new AdvertisementDto();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    city: CityDto;
    governorateId: number | undefined;
    governorate: GovernorateDto;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    duration: DurationDto;
    seekerId: number | undefined;
    seeker: SeekerDto;
    ownerId: number | undefined;
    owner: OwnerDto;
    companyId: number | undefined;
    company: CompanyDto;
    brokerPersonId: number | undefined;
    brokerPerson: BrokerPersonDto;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    proximityToTheSea: ProximityToTheSeaType;
    officies: OfficiesType;
    airConditioner: boolean | undefined;
    diningRoom: boolean | undefined;
    dinning: number | undefined;
    rent: RentType;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookForChalet: DefinitionDto;
    points: number | undefined;
    views: AdViewDto[] | undefined;
    advertisementFacilites: AdvertisementFacilityDto[] | undefined;
    photos: PhotoDto[] | undefined;
    layouts: LayoutDto[] | undefined;
    advertisementFacilitesList: number[] | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisementBookings: moment.Moment[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    projectId: number | undefined;
    isEdited: boolean | undefined;
}

export class AdvertisementDtoDataTableOutputDto implements IAdvertisementDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: AdvertisementDto[] | undefined;

    constructor(data?: IAdvertisementDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(AdvertisementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvertisementDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): AdvertisementDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new AdvertisementDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: AdvertisementDto[] | undefined;
}

export class AdvertisementFacility implements IAdvertisementFacility {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    facilityId: number;
    facility: Definition;
    advertisementId: number;
    advertisement: Advertisement;

    constructor(data?: IAdvertisementFacility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.facilityId = _data["facilityId"];
            this.facility = _data["facility"] ? Definition.fromJS(_data["facility"]) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementFacility {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementFacility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["facilityId"] = this.facilityId;
        data["facility"] = this.facility ? this.facility.toJSON() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        return data;
    }

    clone(): AdvertisementFacility {
        const json = this.toJSON();
        let result = new AdvertisementFacility();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementFacility {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    facilityId: number;
    facility: Definition;
    advertisementId: number;
    advertisement: Advertisement;
}

export class AdvertisementFacilityDto implements IAdvertisementFacilityDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    facilityId: number;
    facility: DefinitionDto;
    advertisementId: number | undefined;

    constructor(data?: IAdvertisementFacilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.facilityId = _data["facilityId"];
            this.facility = _data["facility"] ? DefinitionDto.fromJS(_data["facility"]) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): AdvertisementFacilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementFacilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["facilityId"] = this.facilityId;
        data["facility"] = this.facility ? this.facility.toJSON() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): AdvertisementFacilityDto {
        const json = this.toJSON();
        let result = new AdvertisementFacilityDto();
        result.init(json);
        return result;
    }
}

export interface IAdvertisementFacilityDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    facilityId: number;
    facility: DefinitionDto;
    advertisementId: number | undefined;
}

export enum AgreementStatus {
    _1 = 1,
    _2 = 2,
}

export class ApiAdPointDto implements IApiAdPointDto {
    id: number;
    title: string | undefined;
    points: number;

    constructor(data?: IApiAdPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.points = _data["points"];
        }
    }

    static fromJS(data: any): ApiAdPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["points"] = this.points;
        return data;
    }

    clone(): ApiAdPointDto {
        const json = this.toJSON();
        let result = new ApiAdPointDto();
        result.init(json);
        return result;
    }
}

export interface IApiAdPointDto {
    id: number;
    title: string | undefined;
    points: number;
}

export class ApiAdsPointsOut implements IApiAdsPointsOut {
    advertisements: ApiAdPointDto[] | undefined;
    totalPoints: number | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiAdsPointsOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(ApiAdPointDto.fromJS(item));
            }
            this.totalPoints = _data["totalPoints"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiAdsPointsOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdsPointsOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        data["totalPoints"] = this.totalPoints;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiAdsPointsOut {
        const json = this.toJSON();
        let result = new ApiAdsPointsOut();
        result.init(json);
        return result;
    }
}

export interface IApiAdsPointsOut {
    advertisements: ApiAdPointDto[] | undefined;
    totalPoints: number | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiAdvertiseDetailsDtoOut implements IApiAdvertiseDetailsDtoOut {
    details: ApiGetAdvertiseDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiAdvertiseDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiGetAdvertiseDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiAdvertiseDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertiseDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiAdvertiseDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiAdvertiseDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertiseDetailsDtoOut {
    details: ApiGetAdvertiseDto;
    success: boolean;
    error: string | undefined;
}

export class ApiAdvertiseDetailsMapDtoOut implements IApiAdvertiseDetailsMapDtoOut {
    details: ApiAdvertiseMapDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiAdvertiseDetailsMapDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiAdvertiseMapDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiAdvertiseDetailsMapDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertiseDetailsMapDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiAdvertiseDetailsMapDtoOut {
        const json = this.toJSON();
        let result = new ApiAdvertiseDetailsMapDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertiseDetailsMapDtoOut {
    details: ApiAdvertiseMapDto;
    success: boolean;
    error: string | undefined;
}

export class ApiAdvertiseMapDto implements IApiAdvertiseMapDto {
    title: string | undefined;
    price: string | undefined;

    constructor(data?: IApiAdvertiseMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ApiAdvertiseMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertiseMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["price"] = this.price;
        return data;
    }

    clone(): ApiAdvertiseMapDto {
        const json = this.toJSON();
        let result = new ApiAdvertiseMapDto();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertiseMapDto {
    title: string | undefined;
    price: string | undefined;
}

export class ApiAdvertisementForUserInput implements IApiAdvertisementForUserInput {
    start: number | undefined;
    length: number | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;

    constructor(data?: IApiAdvertisementForUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.length = _data["length"];
            this.brokerId = _data["brokerId"];
            this.seekerId = _data["seekerId"];
            this.ownerId = _data["ownerId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): ApiAdvertisementForUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertisementForUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["length"] = this.length;
        data["brokerId"] = this.brokerId;
        data["seekerId"] = this.seekerId;
        data["ownerId"] = this.ownerId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): ApiAdvertisementForUserInput {
        const json = this.toJSON();
        let result = new ApiAdvertisementForUserInput();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertisementForUserInput {
    start: number | undefined;
    length: number | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
}

export class ApiAdvertisementSearchInput implements IApiAdvertisementSearchInput {
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    streetOrCompund: string | undefined;
    rooms: number | undefined;
    area: string | undefined;
    areaFrom: number | undefined;
    areaTo: number | undefined;
    decoration: DecorationStatus;
    furnished: boolean | undefined;
    parking: boolean | undefined;
    agreementStatus: AgreementStatus;
    priceFrom: number | undefined;
    priceTo: number | undefined;
    isEdited: boolean | undefined;
    companyId: number | undefined;

    constructor(data?: IApiAdvertisementSearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.governorateId = _data["governorateId"];
            this.streetOrCompund = _data["streetOrCompund"];
            this.rooms = _data["rooms"];
            this.area = _data["area"];
            this.areaFrom = _data["areaFrom"];
            this.areaTo = _data["areaTo"];
            this.decoration = _data["decoration"];
            this.furnished = _data["furnished"];
            this.parking = _data["parking"];
            this.agreementStatus = _data["agreementStatus"];
            this.priceFrom = _data["priceFrom"];
            this.priceTo = _data["priceTo"];
            this.isEdited = _data["isEdited"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): ApiAdvertisementSearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertisementSearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["governorateId"] = this.governorateId;
        data["streetOrCompund"] = this.streetOrCompund;
        data["rooms"] = this.rooms;
        data["area"] = this.area;
        data["areaFrom"] = this.areaFrom;
        data["areaTo"] = this.areaTo;
        data["decoration"] = this.decoration;
        data["furnished"] = this.furnished;
        data["parking"] = this.parking;
        data["agreementStatus"] = this.agreementStatus;
        data["priceFrom"] = this.priceFrom;
        data["priceTo"] = this.priceTo;
        data["isEdited"] = this.isEdited;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): ApiAdvertisementSearchInput {
        const json = this.toJSON();
        let result = new ApiAdvertisementSearchInput();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertisementSearchInput {
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    streetOrCompund: string | undefined;
    rooms: number | undefined;
    area: string | undefined;
    areaFrom: number | undefined;
    areaTo: number | undefined;
    decoration: DecorationStatus;
    furnished: boolean | undefined;
    parking: boolean | undefined;
    agreementStatus: AgreementStatus;
    priceFrom: number | undefined;
    priceTo: number | undefined;
    isEdited: boolean | undefined;
    companyId: number | undefined;
}

export class ApiAdvertisesInput implements IApiAdvertisesInput {
    advertiseId: number | undefined;

    constructor(data?: IApiAdvertisesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertiseId = _data["advertiseId"];
        }
    }

    static fromJS(data: any): ApiAdvertisesInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAdvertisesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertiseId"] = this.advertiseId;
        return data;
    }

    clone(): ApiAdvertisesInput {
        const json = this.toJSON();
        let result = new ApiAdvertisesInput();
        result.init(json);
        return result;
    }
}

export interface IApiAdvertisesInput {
    advertiseId: number | undefined;
}

export class ApiAllAdsDto implements IApiAllAdsDto {
    id: number;
    title: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    isPublish: boolean;
    viewCount: number | undefined;
    photos: string[] | undefined;
    price: string | undefined;
    featuredAd: boolean | undefined;
    isCompany: boolean;
    companyLogo: string | undefined;

    constructor(data?: IApiAllAdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.viewCount = _data["viewCount"];
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(item);
            }
            this.price = _data["price"];
            this.featuredAd = _data["featuredAd"];
            this.isCompany = _data["isCompany"];
            this.companyLogo = _data["companyLogo"];
        }
    }

    static fromJS(data: any): ApiAllAdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAllAdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["viewCount"] = this.viewCount;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item);
        }
        data["price"] = this.price;
        data["featuredAd"] = this.featuredAd;
        data["isCompany"] = this.isCompany;
        data["companyLogo"] = this.companyLogo;
        return data;
    }

    clone(): ApiAllAdsDto {
        const json = this.toJSON();
        let result = new ApiAllAdsDto();
        result.init(json);
        return result;
    }
}

export interface IApiAllAdsDto {
    id: number;
    title: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    isPublish: boolean;
    viewCount: number | undefined;
    photos: string[] | undefined;
    price: string | undefined;
    featuredAd: boolean | undefined;
    isCompany: boolean;
    companyLogo: string | undefined;
}

export class ApiAllAdstOut implements IApiAllAdstOut {
    advertisements: ApiAllAdsDto[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiAllAdstOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(ApiAllAdsDto.fromJS(item));
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiAllAdstOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAllAdstOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiAllAdstOut {
        const json = this.toJSON();
        let result = new ApiAllAdstOut();
        result.init(json);
        return result;
    }
}

export interface IApiAllAdstOut {
    advertisements: ApiAllAdsDto[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiBrokerPersonDetailsDto implements IApiBrokerPersonDetailsDto {
    secondMobile: string | undefined;
    isWhatsApp: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;

    constructor(data?: IApiBrokerPersonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secondMobile = _data["secondMobile"];
            this.isWhatsApp = _data["isWhatsApp"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): ApiBrokerPersonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiBrokerPersonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secondMobile"] = this.secondMobile;
        data["isWhatsApp"] = this.isWhatsApp;
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["avatar"] = this.avatar;
        return data;
    }

    clone(): ApiBrokerPersonDetailsDto {
        const json = this.toJSON();
        let result = new ApiBrokerPersonDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IApiBrokerPersonDetailsDto {
    secondMobile: string | undefined;
    isWhatsApp: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
}

export class ApiBrokerPersonDetailsDtoOut implements IApiBrokerPersonDetailsDtoOut {
    details: ApiBrokerPersonDetailsDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiBrokerPersonDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiBrokerPersonDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiBrokerPersonDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiBrokerPersonDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiBrokerPersonDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiBrokerPersonDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiBrokerPersonDetailsDtoOut {
    details: ApiBrokerPersonDetailsDto;
    success: boolean;
    error: string | undefined;
}

export class ApiChangePasswordDto implements IApiChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IApiChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ApiChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ApiChangePasswordDto {
        const json = this.toJSON();
        let result = new ApiChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IApiChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class ApiChangePasswordOut implements IApiChangePasswordOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IApiChangePasswordOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.msg = _data["msg"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiChangePasswordOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiChangePasswordOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["msg"] = this.msg;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): ApiChangePasswordOut {
        const json = this.toJSON();
        let result = new ApiChangePasswordOut();
        result.init(json);
        return result;
    }
}

export interface IApiChangePasswordOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class ApiCityDto implements IApiCityDto {
    id: number;
    name: string | undefined;

    constructor(data?: IApiCityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ApiCityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ApiCityDto {
        const json = this.toJSON();
        let result = new ApiCityDto();
        result.init(json);
        return result;
    }
}

export interface IApiCityDto {
    id: number;
    name: string | undefined;
}

export class ApiCommonyDto implements IApiCommonyDto {
    phoneOrEmail: string | undefined;

    constructor(data?: IApiCommonyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneOrEmail = _data["phoneOrEmail"];
        }
    }

    static fromJS(data: any): ApiCommonyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCommonyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneOrEmail"] = this.phoneOrEmail;
        return data;
    }

    clone(): ApiCommonyDto {
        const json = this.toJSON();
        let result = new ApiCommonyDto();
        result.init(json);
        return result;
    }
}

export interface IApiCommonyDto {
    phoneOrEmail: string | undefined;
}

export class ApiCompaniesDto implements IApiCompaniesDto {
    name: string | undefined;
    logo: string | undefined;

    constructor(data?: IApiCompaniesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.logo = _data["logo"];
        }
    }

    static fromJS(data: any): ApiCompaniesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompaniesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        return data;
    }

    clone(): ApiCompaniesDto {
        const json = this.toJSON();
        let result = new ApiCompaniesDto();
        result.init(json);
        return result;
    }
}

export interface IApiCompaniesDto {
    name: string | undefined;
    logo: string | undefined;
}

export class ApiCompanyDetailsDto implements IApiCompanyDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    isSponser: boolean;
    isActive: boolean;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;

    constructor(data?: IApiCompanyDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secondMobile = _data["secondMobile"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.avatar = _data["avatar"];
            this.bwLogo = _data["bwLogo"];
            this.commericalAvatar = _data["commericalAvatar"];
            this.isSponser = _data["isSponser"];
            this.isActive = _data["isActive"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.snapchat = _data["snapchat"];
            this.tiktok = _data["tiktok"];
            this.website = _data["website"];
            this.aboutAr = _data["aboutAr"];
            this.aboutEn = _data["aboutEn"];
            this.about = _data["about"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): ApiCompanyDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secondMobile"] = this.secondMobile;
        data["isWhatsApped"] = this.isWhatsApped;
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["avatar"] = this.avatar;
        data["bwLogo"] = this.bwLogo;
        data["commericalAvatar"] = this.commericalAvatar;
        data["isSponser"] = this.isSponser;
        data["isActive"] = this.isActive;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["snapchat"] = this.snapchat;
        data["tiktok"] = this.tiktok;
        data["website"] = this.website;
        data["aboutAr"] = this.aboutAr;
        data["aboutEn"] = this.aboutEn;
        data["about"] = this.about;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): ApiCompanyDetailsDto {
        const json = this.toJSON();
        let result = new ApiCompanyDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    isSponser: boolean;
    isActive: boolean;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class ApiCompanyDetailsDtoOut implements IApiCompanyDetailsDtoOut {
    details: ApiCompanyDetailsDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCompanyDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiCompanyDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCompanyDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCompanyDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiCompanyDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyDetailsDtoOut {
    details: ApiCompanyDetailsDto;
    success: boolean;
    error: string | undefined;
}

export class ApiCompanyInput implements IApiCompanyInput {
    name: string | undefined;
    isSponsor: boolean | undefined;

    constructor(data?: IApiCompanyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSponsor = _data["isSponsor"];
        }
    }

    static fromJS(data: any): ApiCompanyInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSponsor"] = this.isSponsor;
        return data;
    }

    clone(): ApiCompanyInput {
        const json = this.toJSON();
        let result = new ApiCompanyInput();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyInput {
    name: string | undefined;
    isSponsor: boolean | undefined;
}

export class ApiCompanyPackageDto implements IApiCompanyPackageDto {
    name: string | undefined;
    price: number;
    points: number;
    companyBalance: number | undefined;
    brolerPoints: number | undefined;

    constructor(data?: IApiCompanyPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            this.points = _data["points"];
            this.companyBalance = _data["companyBalance"];
            this.brolerPoints = _data["brolerPoints"];
        }
    }

    static fromJS(data: any): ApiCompanyPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["points"] = this.points;
        data["companyBalance"] = this.companyBalance;
        data["brolerPoints"] = this.brolerPoints;
        return data;
    }

    clone(): ApiCompanyPackageDto {
        const json = this.toJSON();
        let result = new ApiCompanyPackageDto();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyPackageDto {
    name: string | undefined;
    price: number;
    points: number;
    companyBalance: number | undefined;
    brolerPoints: number | undefined;
}

export class ApiCompanyPackageDtoOut implements IApiCompanyPackageDtoOut {
    details: ApiCompanyPackageDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCompanyPackageDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiCompanyPackageDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCompanyPackageDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyPackageDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCompanyPackageDtoOut {
        const json = this.toJSON();
        let result = new ApiCompanyPackageDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyPackageDtoOut {
    details: ApiCompanyPackageDto;
    success: boolean;
    error: string | undefined;
}

export class ApiCompanyiesOut implements IApiCompanyiesOut {
    companies: ApiCompaniesDto[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCompanyiesOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies.push(ApiCompaniesDto.fromJS(item));
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCompanyiesOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCompanyiesOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCompanyiesOut {
        const json = this.toJSON();
        let result = new ApiCompanyiesOut();
        result.init(json);
        return result;
    }
}

export interface IApiCompanyiesOut {
    companies: ApiCompaniesDto[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCountryDto implements IApiCountryDto {
    id: number;
    name: string | undefined;

    constructor(data?: IApiCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ApiCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ApiCountryDto {
        const json = this.toJSON();
        let result = new ApiCountryDto();
        result.init(json);
        return result;
    }
}

export interface IApiCountryDto {
    id: number;
    name: string | undefined;
}

export class ApiCreatAdvertisementOut implements IApiCreatAdvertisementOut {
    advertisementId: number | undefined;
    advertisement: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreatAdvertisementOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreatAdvertisementOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreatAdvertisementOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreatAdvertisementOut {
        const json = this.toJSON();
        let result = new ApiCreatAdvertisementOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreatAdvertisementOut {
    advertisementId: number | undefined;
    advertisement: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateAdvertisementBookingDto implements IApiCreateAdvertisementBookingDto {
    bookingDate: moment.Moment;
    advertisementId: number;

    constructor(data?: IApiCreateAdvertisementBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingDate = _data["bookingDate"] ? moment(_data["bookingDate"].toString()) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): ApiCreateAdvertisementBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateAdvertisementBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toISOString() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): ApiCreateAdvertisementBookingDto {
        const json = this.toJSON();
        let result = new ApiCreateAdvertisementBookingDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateAdvertisementBookingDto {
    bookingDate: moment.Moment;
    advertisementId: number;
}

export class ApiCreateAdvertisementBookingOut implements IApiCreateAdvertisementBookingOut {
    advertisementBookingId: number | undefined;
    advertisementBooking: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateAdvertisementBookingOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementBookingId = _data["advertisementBookingId"];
            this.advertisementBooking = _data["advertisementBooking"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateAdvertisementBookingOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateAdvertisementBookingOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementBookingId"] = this.advertisementBookingId;
        data["advertisementBooking"] = this.advertisementBooking;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateAdvertisementBookingOut {
        const json = this.toJSON();
        let result = new ApiCreateAdvertisementBookingOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateAdvertisementBookingOut {
    advertisementBookingId: number | undefined;
    advertisementBooking: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateAdvertisementDto implements IApiCreateAdvertisementDto {
    id: number;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
    brokerPersonId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookName: string | undefined;
    showChalet: boolean | undefined;
    dinning: number | undefined;
    rent: RentType;
    diningRoom: boolean | undefined;
    officies: OfficiesType;
    layoutsList: string[] | undefined;
    photosList: string[] | undefined;
    advertisementFacilitesList: number[] | undefined;
    advertisementBookings: moment.Moment[] | undefined;
    facilitesApi: FacilityDtoForEdit[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    airConditioner: boolean | undefined;
    isEdited: boolean | undefined;
    projectId: number | undefined;

    constructor(data?: IApiCreateAdvertisementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.governorateId = _data["governorateId"];
            this.compound = _data["compound"];
            this.street = _data["street"];
            this.buildingNumber = _data["buildingNumber"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.floorsNumber = _data["floorsNumber"];
            this.area = _data["area"];
            this.buildingArea = _data["buildingArea"];
            this.chaletType = _data["chaletType"];
            this.agreementStatus = _data["agreementStatus"];
            this.buildingStatus = _data["buildingStatus"];
            this.landingStatus = _data["landingStatus"];
            this.usingFor = _data["usingFor"];
            this.streetWidth = _data["streetWidth"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.buildingDate = _data["buildingDate"] ? moment(_data["buildingDate"].toString()) : <any>undefined;
            this.rooms = _data["rooms"];
            this.reception = _data["reception"];
            this.balcony = _data["balcony"];
            this.kitchen = _data["kitchen"];
            this.toilet = _data["toilet"];
            this.numUnits = _data["numUnits"];
            this.numPartitions = _data["numPartitions"];
            this.officesNum = _data["officesNum"];
            this.officesFloors = _data["officesFloors"];
            this.durationId = _data["durationId"];
            this.seekerId = _data["seekerId"];
            this.ownerId = _data["ownerId"];
            this.companyId = _data["companyId"];
            this.brokerPersonId = _data["brokerPersonId"];
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            this.description = _data["description"];
            this.featuredAd = _data["featuredAd"];
            this.price = _data["price"];
            this.paymentFacility = _data["paymentFacility"];
            this.mrMrs = _data["mrMrs"];
            this.advertiseMakerName = _data["advertiseMakerName"];
            this.advertiseMaker = _data["advertiseMaker"];
            this.mobileNumber = _data["mobileNumber"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.secondMobileNumber = _data["secondMobileNumber"];
            this.contactRegisterInTheAccount = _data["contactRegisterInTheAccount"];
            this.furnished = _data["furnished"];
            this.elevator = _data["elevator"];
            this.parking = _data["parking"];
            this.parkingSpace = _data["parkingSpace"];
            this.garden = _data["garden"];
            this.gardenArea = _data["gardenArea"];
            this.pool = _data["pool"];
            this.shop = _data["shop"];
            this.shopsNumber = _data["shopsNumber"];
            this.decoration = _data["decoration"];
            this.document = _data["document"];
            this.chaletRentType = _data["chaletRentType"];
            this.chaletRentValue = _data["chaletRentValue"];
            this.numOfMonths = _data["numOfMonths"];
            this.minTimeToBookForChaletId = _data["minTimeToBookForChaletId"];
            this.minTimeToBookName = _data["minTimeToBookName"];
            this.showChalet = _data["showChalet"];
            this.dinning = _data["dinning"];
            this.rent = _data["rent"];
            this.diningRoom = _data["diningRoom"];
            this.officies = _data["officies"];
            if (Array.isArray(_data["layoutsList"])) {
                this.layoutsList = [] as any;
                for (let item of _data["layoutsList"])
                    this.layoutsList.push(item);
            }
            if (Array.isArray(_data["photosList"])) {
                this.photosList = [] as any;
                for (let item of _data["photosList"])
                    this.photosList.push(item);
            }
            if (Array.isArray(_data["advertisementFacilitesList"])) {
                this.advertisementFacilitesList = [] as any;
                for (let item of _data["advertisementFacilitesList"])
                    this.advertisementFacilitesList.push(item);
            }
            if (Array.isArray(_data["advertisementBookings"])) {
                this.advertisementBookings = [] as any;
                for (let item of _data["advertisementBookings"])
                    this.advertisementBookings.push(moment(item));
            }
            if (Array.isArray(_data["facilitesApi"])) {
                this.facilitesApi = [] as any;
                for (let item of _data["facilitesApi"])
                    this.facilitesApi.push(FacilityDtoForEdit.fromJS(item));
            }
            this.downPayment = _data["downPayment"];
            this.monthlyInstallment = _data["monthlyInstallment"];
            this.yearlyInstallment = _data["yearlyInstallment"];
            this.numOfYears = _data["numOfYears"];
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.airConditioner = _data["airConditioner"];
            this.isEdited = _data["isEdited"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ApiCreateAdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateAdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["governorateId"] = this.governorateId;
        data["compound"] = this.compound;
        data["street"] = this.street;
        data["buildingNumber"] = this.buildingNumber;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["floorsNumber"] = this.floorsNumber;
        data["area"] = this.area;
        data["buildingArea"] = this.buildingArea;
        data["chaletType"] = this.chaletType;
        data["agreementStatus"] = this.agreementStatus;
        data["buildingStatus"] = this.buildingStatus;
        data["landingStatus"] = this.landingStatus;
        data["usingFor"] = this.usingFor;
        data["streetWidth"] = this.streetWidth;
        data["width"] = this.width;
        data["length"] = this.length;
        data["buildingDate"] = this.buildingDate ? this.buildingDate.toISOString() : <any>undefined;
        data["rooms"] = this.rooms;
        data["reception"] = this.reception;
        data["balcony"] = this.balcony;
        data["kitchen"] = this.kitchen;
        data["toilet"] = this.toilet;
        data["numUnits"] = this.numUnits;
        data["numPartitions"] = this.numPartitions;
        data["officesNum"] = this.officesNum;
        data["officesFloors"] = this.officesFloors;
        data["durationId"] = this.durationId;
        data["seekerId"] = this.seekerId;
        data["ownerId"] = this.ownerId;
        data["companyId"] = this.companyId;
        data["brokerPersonId"] = this.brokerPersonId;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        data["description"] = this.description;
        data["featuredAd"] = this.featuredAd;
        data["price"] = this.price;
        data["paymentFacility"] = this.paymentFacility;
        data["mrMrs"] = this.mrMrs;
        data["advertiseMakerName"] = this.advertiseMakerName;
        data["advertiseMaker"] = this.advertiseMaker;
        data["mobileNumber"] = this.mobileNumber;
        data["isWhatsApped"] = this.isWhatsApped;
        data["secondMobileNumber"] = this.secondMobileNumber;
        data["contactRegisterInTheAccount"] = this.contactRegisterInTheAccount;
        data["furnished"] = this.furnished;
        data["elevator"] = this.elevator;
        data["parking"] = this.parking;
        data["parkingSpace"] = this.parkingSpace;
        data["garden"] = this.garden;
        data["gardenArea"] = this.gardenArea;
        data["pool"] = this.pool;
        data["shop"] = this.shop;
        data["shopsNumber"] = this.shopsNumber;
        data["decoration"] = this.decoration;
        data["document"] = this.document;
        data["chaletRentType"] = this.chaletRentType;
        data["chaletRentValue"] = this.chaletRentValue;
        data["numOfMonths"] = this.numOfMonths;
        data["minTimeToBookForChaletId"] = this.minTimeToBookForChaletId;
        data["minTimeToBookName"] = this.minTimeToBookName;
        data["showChalet"] = this.showChalet;
        data["dinning"] = this.dinning;
        data["rent"] = this.rent;
        data["diningRoom"] = this.diningRoom;
        data["officies"] = this.officies;
        if (Array.isArray(this.layoutsList)) {
            data["layoutsList"] = [];
            for (let item of this.layoutsList)
                data["layoutsList"].push(item);
        }
        if (Array.isArray(this.photosList)) {
            data["photosList"] = [];
            for (let item of this.photosList)
                data["photosList"].push(item);
        }
        if (Array.isArray(this.advertisementFacilitesList)) {
            data["advertisementFacilitesList"] = [];
            for (let item of this.advertisementFacilitesList)
                data["advertisementFacilitesList"].push(item);
        }
        if (Array.isArray(this.advertisementBookings)) {
            data["advertisementBookings"] = [];
            for (let item of this.advertisementBookings)
                data["advertisementBookings"].push(item.toISOString());
        }
        if (Array.isArray(this.facilitesApi)) {
            data["facilitesApi"] = [];
            for (let item of this.facilitesApi)
                data["facilitesApi"].push(item.toJSON());
        }
        data["downPayment"] = this.downPayment;
        data["monthlyInstallment"] = this.monthlyInstallment;
        data["yearlyInstallment"] = this.yearlyInstallment;
        data["numOfYears"] = this.numOfYears;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["airConditioner"] = this.airConditioner;
        data["isEdited"] = this.isEdited;
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): ApiCreateAdvertisementDto {
        const json = this.toJSON();
        let result = new ApiCreateAdvertisementDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateAdvertisementDto {
    id: number;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    agreementStatus: AgreementStatus;
    buildingStatus: BuildingStatus;
    landingStatus: LandingStatus;
    usingFor: UsingFor;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
    brokerPersonId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: number;
    paymentFacility: PaymentFacilitiesType;
    mrMrs: MrMrsType;
    advertiseMakerName: string | undefined;
    advertiseMaker: AdvertiseMakerType;
    mobileNumber: string | undefined;
    isWhatsApped: boolean;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    furnished: boolean | undefined;
    elevator: boolean | undefined;
    parking: boolean | undefined;
    parkingSpace: number | undefined;
    garden: boolean | undefined;
    gardenArea: number | undefined;
    pool: boolean | undefined;
    shop: boolean | undefined;
    shopsNumber: number | undefined;
    decoration: DecorationStatus;
    document: DocumentStatus;
    chaletRentType: ChaletRentType;
    chaletRentValue: number | undefined;
    numOfMonths: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookName: string | undefined;
    showChalet: boolean | undefined;
    dinning: number | undefined;
    rent: RentType;
    diningRoom: boolean | undefined;
    officies: OfficiesType;
    layoutsList: string[] | undefined;
    photosList: string[] | undefined;
    advertisementFacilitesList: number[] | undefined;
    advertisementBookings: moment.Moment[] | undefined;
    facilitesApi: FacilityDtoForEdit[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    airConditioner: boolean | undefined;
    isEdited: boolean | undefined;
    projectId: number | undefined;
}

export class ApiCreateBrokerPersonDto implements IApiCreateBrokerPersonDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;

    constructor(data?: IApiCreateBrokerPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
        }
    }

    static fromJS(data: any): ApiCreateBrokerPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateBrokerPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        return data;
    }

    clone(): ApiCreateBrokerPersonDto {
        const json = this.toJSON();
        let result = new ApiCreateBrokerPersonDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateBrokerPersonDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
}

export class ApiCreateBrokerPersonOut implements IApiCreateBrokerPersonOut {
    brokerPersonId: number | undefined;
    brokerPerson: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateBrokerPersonOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brokerPersonId = _data["brokerPersonId"];
            this.brokerPerson = _data["brokerPerson"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateBrokerPersonOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateBrokerPersonOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerPersonId"] = this.brokerPersonId;
        data["brokerPerson"] = this.brokerPerson;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateBrokerPersonOut {
        const json = this.toJSON();
        let result = new ApiCreateBrokerPersonOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateBrokerPersonOut {
    brokerPersonId: number | undefined;
    brokerPerson: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateCompanyDto implements IApiCreateCompanyDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;

    constructor(data?: IApiCreateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
        }
    }

    static fromJS(data: any): ApiCreateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        return data;
    }

    clone(): ApiCreateCompanyDto {
        const json = this.toJSON();
        let result = new ApiCreateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateCompanyDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
}

export class ApiCreateCompanyOut implements IApiCreateCompanyOut {
    companyId: number | undefined;
    company: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateCompanyOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.company = _data["company"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateCompanyOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateCompanyOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["company"] = this.company;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateCompanyOut {
        const json = this.toJSON();
        let result = new ApiCreateCompanyOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateCompanyOut {
    companyId: number | undefined;
    company: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateContactUsDto implements IApiCreateContactUsDto {
    emailAddress: string | undefined;
    emailSubject: string | undefined;
    attachmentPath: string | undefined;
    userId: number | undefined;

    constructor(data?: IApiCreateContactUsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.emailSubject = _data["emailSubject"];
            this.attachmentPath = _data["attachmentPath"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ApiCreateContactUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateContactUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["emailSubject"] = this.emailSubject;
        data["attachmentPath"] = this.attachmentPath;
        data["userId"] = this.userId;
        return data;
    }

    clone(): ApiCreateContactUsDto {
        const json = this.toJSON();
        let result = new ApiCreateContactUsDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateContactUsDto {
    emailAddress: string | undefined;
    emailSubject: string | undefined;
    attachmentPath: string | undefined;
    userId: number | undefined;
}

export class ApiCreateContactUsOut implements IApiCreateContactUsOut {
    contactUsId: number | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateContactUsOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactUsId = _data["contactUsId"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateContactUsOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateContactUsOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactUsId"] = this.contactUsId;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateContactUsOut {
        const json = this.toJSON();
        let result = new ApiCreateContactUsOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateContactUsOut {
    contactUsId: number | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateFavoritetDto implements IApiCreateFavoritetDto {
    id: number;
    userId: number;
    advertisementId: number;

    constructor(data?: IApiCreateFavoritetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): ApiCreateFavoritetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateFavoritetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): ApiCreateFavoritetDto {
        const json = this.toJSON();
        let result = new ApiCreateFavoritetDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateFavoritetDto {
    id: number;
    userId: number;
    advertisementId: number;
}

export class ApiCreateFavoritetOut implements IApiCreateFavoritetOut {
    favoriteId: number | undefined;
    adFavorite: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateFavoritetOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.favoriteId = _data["favoriteId"];
            this.adFavorite = _data["adFavorite"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateFavoritetOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateFavoritetOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["favoriteId"] = this.favoriteId;
        data["adFavorite"] = this.adFavorite;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateFavoritetOut {
        const json = this.toJSON();
        let result = new ApiCreateFavoritetOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateFavoritetOut {
    favoriteId: number | undefined;
    adFavorite: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateOwnerDto implements IApiCreateOwnerDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;

    constructor(data?: IApiCreateOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
        }
    }

    static fromJS(data: any): ApiCreateOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        return data;
    }

    clone(): ApiCreateOwnerDto {
        const json = this.toJSON();
        let result = new ApiCreateOwnerDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateOwnerDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
}

export class ApiCreateOwnerOut implements IApiCreateOwnerOut {
    ownerId: number | undefined;
    owner: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateOwnerOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateOwnerOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateOwnerOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateOwnerOut {
        const json = this.toJSON();
        let result = new ApiCreateOwnerOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateOwnerOut {
    ownerId: number | undefined;
    owner: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateRateDto implements IApiCreateRateDto {
    userId: number;
    userRate: number;

    constructor(data?: IApiCreateRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userRate = _data["userRate"];
        }
    }

    static fromJS(data: any): ApiCreateRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userRate"] = this.userRate;
        return data;
    }

    clone(): ApiCreateRateDto {
        const json = this.toJSON();
        let result = new ApiCreateRateDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateRateDto {
    userId: number;
    userRate: number;
}

export class ApiCreateRateOut implements IApiCreateRateOut {
    rateId: number | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateRateOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rateId = _data["rateId"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateRateOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateRateOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rateId"] = this.rateId;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateRateOut {
        const json = this.toJSON();
        let result = new ApiCreateRateOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateRateOut {
    rateId: number | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateSeekerDto implements IApiCreateSeekerDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;

    constructor(data?: IApiCreateSeekerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
        }
    }

    static fromJS(data: any): ApiCreateSeekerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateSeekerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        return data;
    }

    clone(): ApiCreateSeekerDto {
        const json = this.toJSON();
        let result = new ApiCreateSeekerDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateSeekerDto {
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
}

export class ApiCreateSeekerOut implements IApiCreateSeekerOut {
    seekerId: number | undefined;
    seeker: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateSeekerOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seekerId = _data["seekerId"];
            this.seeker = _data["seeker"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateSeekerOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateSeekerOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seekerId"] = this.seekerId;
        data["seeker"] = this.seeker;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateSeekerOut {
        const json = this.toJSON();
        let result = new ApiCreateSeekerOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateSeekerOut {
    seekerId: number | undefined;
    seeker: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiCreateViewDto implements IApiCreateViewDto {
    userId: number;
    advertisementId: number;

    constructor(data?: IApiCreateViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): ApiCreateViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): ApiCreateViewDto {
        const json = this.toJSON();
        let result = new ApiCreateViewDto();
        result.init(json);
        return result;
    }
}

export interface IApiCreateViewDto {
    userId: number;
    advertisementId: number;
}

export class ApiCreateViewOut implements IApiCreateViewOut {
    viewId: number | undefined;
    adView: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiCreateViewOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewId = _data["viewId"];
            this.adView = _data["adView"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiCreateViewOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCreateViewOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewId"] = this.viewId;
        data["adView"] = this.adView;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiCreateViewOut {
        const json = this.toJSON();
        let result = new ApiCreateViewOut();
        result.init(json);
        return result;
    }
}

export interface IApiCreateViewOut {
    viewId: number | undefined;
    adView: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiDefinitionDto implements IApiDefinitionDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    value: number | undefined;

    constructor(data?: IApiDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.avatar = _data["avatar"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["avatar"] = this.avatar;
        data["value"] = this.value;
        return data;
    }

    clone(): ApiDefinitionDto {
        const json = this.toJSON();
        let result = new ApiDefinitionDto();
        result.init(json);
        return result;
    }
}

export interface IApiDefinitionDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    value: number | undefined;
}

export class ApiDeleteAccountDto implements IApiDeleteAccountDto {
    userId: number;

    constructor(data?: IApiDeleteAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ApiDeleteAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }

    clone(): ApiDeleteAccountDto {
        const json = this.toJSON();
        let result = new ApiDeleteAccountDto();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteAccountDto {
    userId: number;
}

export class ApiDeleteAccountOut implements IApiDeleteAccountOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IApiDeleteAccountOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.msg = _data["msg"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiDeleteAccountOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteAccountOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["msg"] = this.msg;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): ApiDeleteAccountOut {
        const json = this.toJSON();
        let result = new ApiDeleteAccountOut();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteAccountOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class ApiDeleteAdvertisementBookingDto implements IApiDeleteAdvertisementBookingDto {
    advertisementBookingId: number;

    constructor(data?: IApiDeleteAdvertisementBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementBookingId = _data["advertisementBookingId"];
        }
    }

    static fromJS(data: any): ApiDeleteAdvertisementBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteAdvertisementBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementBookingId"] = this.advertisementBookingId;
        return data;
    }

    clone(): ApiDeleteAdvertisementBookingDto {
        const json = this.toJSON();
        let result = new ApiDeleteAdvertisementBookingDto();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteAdvertisementBookingDto {
    advertisementBookingId: number;
}

export class ApiDeleteAdvertisementBookingOut implements IApiDeleteAdvertisementBookingOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IApiDeleteAdvertisementBookingOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.msg = _data["msg"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiDeleteAdvertisementBookingOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteAdvertisementBookingOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["msg"] = this.msg;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): ApiDeleteAdvertisementBookingOut {
        const json = this.toJSON();
        let result = new ApiDeleteAdvertisementBookingOut();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteAdvertisementBookingOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class ApiDeleteProjectDto implements IApiDeleteProjectDto {
    projectId: number;

    constructor(data?: IApiDeleteProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ApiDeleteProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): ApiDeleteProjectDto {
        const json = this.toJSON();
        let result = new ApiDeleteProjectDto();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteProjectDto {
    projectId: number;
}

export class ApiDeleteProjectOut implements IApiDeleteProjectOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IApiDeleteProjectOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.msg = _data["msg"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiDeleteProjectOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDeleteProjectOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["msg"] = this.msg;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): ApiDeleteProjectOut {
        const json = this.toJSON();
        let result = new ApiDeleteProjectOut();
        result.init(json);
        return result;
    }
}

export interface IApiDeleteProjectOut {
    msg: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class ApiDiscountDto implements IApiDiscountDto {
    percentage: number | undefined;

    constructor(data?: IApiDiscountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): ApiDiscountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDiscountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        return data;
    }

    clone(): ApiDiscountDto {
        const json = this.toJSON();
        let result = new ApiDiscountDto();
        result.init(json);
        return result;
    }
}

export interface IApiDiscountDto {
    percentage: number | undefined;
}

export class ApiDurationDto implements IApiDurationDto {
    id: number;
    period: number;
    amount: number;
    types: string[] | undefined;
    isPublish: boolean;

    constructor(data?: IApiDurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.period = _data["period"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types.push(item);
            }
            this.isPublish = _data["isPublish"];
        }
    }

    static fromJS(data: any): ApiDurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["period"] = this.period;
        data["amount"] = this.amount;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["isPublish"] = this.isPublish;
        return data;
    }

    clone(): ApiDurationDto {
        const json = this.toJSON();
        let result = new ApiDurationDto();
        result.init(json);
        return result;
    }
}

export interface IApiDurationDto {
    id: number;
    period: number;
    amount: number;
    types: string[] | undefined;
    isPublish: boolean;
}

export class ApiFavoriteDto implements IApiFavoriteDto {
    id: number;
    advertisementId: number;
    title: string | undefined;
    buildingType: BuildingType;
    longitude: number | undefined;
    latitude: number | undefined;
    cityName: string | undefined;
    governorateName: string | undefined;
    isPublish: boolean;
    price: string | undefined;
    photos: string[] | undefined;

    constructor(data?: IApiFavoriteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.advertisementId = _data["advertisementId"];
            this.title = _data["title"];
            this.buildingType = _data["buildingType"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.cityName = _data["cityName"];
            this.governorateName = _data["governorateName"];
            this.isPublish = _data["isPublish"];
            this.price = _data["price"];
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(item);
            }
        }
    }

    static fromJS(data: any): ApiFavoriteDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiFavoriteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["advertisementId"] = this.advertisementId;
        data["title"] = this.title;
        data["buildingType"] = this.buildingType;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["cityName"] = this.cityName;
        data["governorateName"] = this.governorateName;
        data["isPublish"] = this.isPublish;
        data["price"] = this.price;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item);
        }
        return data;
    }

    clone(): ApiFavoriteDto {
        const json = this.toJSON();
        let result = new ApiFavoriteDto();
        result.init(json);
        return result;
    }
}

export interface IApiFavoriteDto {
    id: number;
    advertisementId: number;
    title: string | undefined;
    buildingType: BuildingType;
    longitude: number | undefined;
    latitude: number | undefined;
    cityName: string | undefined;
    governorateName: string | undefined;
    isPublish: boolean;
    price: string | undefined;
    photos: string[] | undefined;
}

export class ApiFavoriteInput implements IApiFavoriteInput {
    userId: number;

    constructor(data?: IApiFavoriteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ApiFavoriteInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiFavoriteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }

    clone(): ApiFavoriteInput {
        const json = this.toJSON();
        let result = new ApiFavoriteInput();
        result.init(json);
        return result;
    }
}

export interface IApiFavoriteInput {
    userId: number;
}

export class ApiFavoriteOut implements IApiFavoriteOut {
    favorites: ApiFavoriteDto[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiFavoriteOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["favorites"])) {
                this.favorites = [] as any;
                for (let item of _data["favorites"])
                    this.favorites.push(ApiFavoriteDto.fromJS(item));
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiFavoriteOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiFavoriteOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.favorites)) {
            data["favorites"] = [];
            for (let item of this.favorites)
                data["favorites"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiFavoriteOut {
        const json = this.toJSON();
        let result = new ApiFavoriteOut();
        result.init(json);
        return result;
    }
}

export interface IApiFavoriteOut {
    favorites: ApiFavoriteDto[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiGetAdvertiseDto implements IApiGetAdvertiseDto {
    id: number;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    governorateName: string | undefined;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    buildingStatus: string | undefined;
    landingStatus: string | undefined;
    usingFor: UsingFor;
    usingForString: string | undefined;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
    brokerPersonId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: string | undefined;
    paymentFacility: PaymentFacilitiesType;
    advertiseMakerName: string | undefined;
    advertiseMaker: string | undefined;
    mobileNumber: string | undefined;
    isWhatsApped: string | undefined;
    whatsApped: boolean | undefined;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    parkingSpace: number | undefined;
    garden: string | undefined;
    gardenArea: number | undefined;
    pool: string | undefined;
    shop: string | undefined;
    shopsNumber: number | undefined;
    dinning: number | undefined;
    rent: RentType;
    rentValue: string | undefined;
    diningRoom: string | undefined;
    facilites: FacilityDtoApi[] | undefined;
    photos: string[] | undefined;
    layouts: string[] | undefined;
    decoration: string | undefined;
    document: string | undefined;
    viewsCount: number | undefined;
    agreementStatus: string | undefined;
    agreementStatusId: AgreementStatus;
    furnished: string | undefined;
    elevator: string | undefined;
    parking: string | undefined;
    propertyFor: string | undefined;
    chaletRentType: ChaletRentType;
    chaletRentTypeString: string | undefined;
    numOfMonths: number | undefined;
    chaletRentValue: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookName: string | undefined;
    showChalet: boolean | undefined;
    officies: OfficiesType;
    advertisementBookings: moment.Moment[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    isEdited: boolean | undefined;
    isCompany: boolean;
    companyLogo: string | undefined;
    companyAbout: string | undefined;
    companyFacebook: string | undefined;
    companyInstagram: string | undefined;
    companySnapchat: string | undefined;
    companyTiktok: string | undefined;
    companyWebsite: string | undefined;
    companyName: string | undefined;
    companyLatitude: number | undefined;
    companyLongitude: number | undefined;
    projectName: string | undefined;

    constructor(data?: IApiGetAdvertiseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.governorateId = _data["governorateId"];
            this.governorateName = _data["governorateName"];
            this.compound = _data["compound"];
            this.street = _data["street"];
            this.buildingNumber = _data["buildingNumber"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.floorsNumber = _data["floorsNumber"];
            this.area = _data["area"];
            this.buildingArea = _data["buildingArea"];
            this.chaletType = _data["chaletType"];
            this.buildingStatus = _data["buildingStatus"];
            this.landingStatus = _data["landingStatus"];
            this.usingFor = _data["usingFor"];
            this.usingForString = _data["usingForString"];
            this.streetWidth = _data["streetWidth"];
            this.width = _data["width"];
            this.length = _data["length"];
            this.buildingDate = _data["buildingDate"] ? moment(_data["buildingDate"].toString()) : <any>undefined;
            this.rooms = _data["rooms"];
            this.reception = _data["reception"];
            this.balcony = _data["balcony"];
            this.kitchen = _data["kitchen"];
            this.toilet = _data["toilet"];
            this.numUnits = _data["numUnits"];
            this.numPartitions = _data["numPartitions"];
            this.officesNum = _data["officesNum"];
            this.officesFloors = _data["officesFloors"];
            this.durationId = _data["durationId"];
            this.seekerId = _data["seekerId"];
            this.ownerId = _data["ownerId"];
            this.companyId = _data["companyId"];
            this.brokerPersonId = _data["brokerPersonId"];
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            this.description = _data["description"];
            this.featuredAd = _data["featuredAd"];
            this.price = _data["price"];
            this.paymentFacility = _data["paymentFacility"];
            this.advertiseMakerName = _data["advertiseMakerName"];
            this.advertiseMaker = _data["advertiseMaker"];
            this.mobileNumber = _data["mobileNumber"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.whatsApped = _data["whatsApped"];
            this.secondMobileNumber = _data["secondMobileNumber"];
            this.contactRegisterInTheAccount = _data["contactRegisterInTheAccount"];
            this.parkingSpace = _data["parkingSpace"];
            this.garden = _data["garden"];
            this.gardenArea = _data["gardenArea"];
            this.pool = _data["pool"];
            this.shop = _data["shop"];
            this.shopsNumber = _data["shopsNumber"];
            this.dinning = _data["dinning"];
            this.rent = _data["rent"];
            this.rentValue = _data["rentValue"];
            this.diningRoom = _data["diningRoom"];
            if (Array.isArray(_data["facilites"])) {
                this.facilites = [] as any;
                for (let item of _data["facilites"])
                    this.facilites.push(FacilityDtoApi.fromJS(item));
            }
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(item);
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts.push(item);
            }
            this.decoration = _data["decoration"];
            this.document = _data["document"];
            this.viewsCount = _data["viewsCount"];
            this.agreementStatus = _data["agreementStatus"];
            this.agreementStatusId = _data["agreementStatusId"];
            this.furnished = _data["furnished"];
            this.elevator = _data["elevator"];
            this.parking = _data["parking"];
            this.propertyFor = _data["propertyFor"];
            this.chaletRentType = _data["chaletRentType"];
            this.chaletRentTypeString = _data["chaletRentTypeString"];
            this.numOfMonths = _data["numOfMonths"];
            this.chaletRentValue = _data["chaletRentValue"];
            this.minTimeToBookForChaletId = _data["minTimeToBookForChaletId"];
            this.minTimeToBookName = _data["minTimeToBookName"];
            this.showChalet = _data["showChalet"];
            this.officies = _data["officies"];
            if (Array.isArray(_data["advertisementBookings"])) {
                this.advertisementBookings = [] as any;
                for (let item of _data["advertisementBookings"])
                    this.advertisementBookings.push(moment(item));
            }
            this.downPayment = _data["downPayment"];
            this.monthlyInstallment = _data["monthlyInstallment"];
            this.yearlyInstallment = _data["yearlyInstallment"];
            this.numOfYears = _data["numOfYears"];
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.isEdited = _data["isEdited"];
            this.isCompany = _data["isCompany"];
            this.companyLogo = _data["companyLogo"];
            this.companyAbout = _data["companyAbout"];
            this.companyFacebook = _data["companyFacebook"];
            this.companyInstagram = _data["companyInstagram"];
            this.companySnapchat = _data["companySnapchat"];
            this.companyTiktok = _data["companyTiktok"];
            this.companyWebsite = _data["companyWebsite"];
            this.companyName = _data["companyName"];
            this.companyLatitude = _data["companyLatitude"];
            this.companyLongitude = _data["companyLongitude"];
            this.projectName = _data["projectName"];
        }
    }

    static fromJS(data: any): ApiGetAdvertiseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiGetAdvertiseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["governorateId"] = this.governorateId;
        data["governorateName"] = this.governorateName;
        data["compound"] = this.compound;
        data["street"] = this.street;
        data["buildingNumber"] = this.buildingNumber;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["floorsNumber"] = this.floorsNumber;
        data["area"] = this.area;
        data["buildingArea"] = this.buildingArea;
        data["chaletType"] = this.chaletType;
        data["buildingStatus"] = this.buildingStatus;
        data["landingStatus"] = this.landingStatus;
        data["usingFor"] = this.usingFor;
        data["usingForString"] = this.usingForString;
        data["streetWidth"] = this.streetWidth;
        data["width"] = this.width;
        data["length"] = this.length;
        data["buildingDate"] = this.buildingDate ? this.buildingDate.toISOString() : <any>undefined;
        data["rooms"] = this.rooms;
        data["reception"] = this.reception;
        data["balcony"] = this.balcony;
        data["kitchen"] = this.kitchen;
        data["toilet"] = this.toilet;
        data["numUnits"] = this.numUnits;
        data["numPartitions"] = this.numPartitions;
        data["officesNum"] = this.officesNum;
        data["officesFloors"] = this.officesFloors;
        data["durationId"] = this.durationId;
        data["seekerId"] = this.seekerId;
        data["ownerId"] = this.ownerId;
        data["companyId"] = this.companyId;
        data["brokerPersonId"] = this.brokerPersonId;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        data["description"] = this.description;
        data["featuredAd"] = this.featuredAd;
        data["price"] = this.price;
        data["paymentFacility"] = this.paymentFacility;
        data["advertiseMakerName"] = this.advertiseMakerName;
        data["advertiseMaker"] = this.advertiseMaker;
        data["mobileNumber"] = this.mobileNumber;
        data["isWhatsApped"] = this.isWhatsApped;
        data["whatsApped"] = this.whatsApped;
        data["secondMobileNumber"] = this.secondMobileNumber;
        data["contactRegisterInTheAccount"] = this.contactRegisterInTheAccount;
        data["parkingSpace"] = this.parkingSpace;
        data["garden"] = this.garden;
        data["gardenArea"] = this.gardenArea;
        data["pool"] = this.pool;
        data["shop"] = this.shop;
        data["shopsNumber"] = this.shopsNumber;
        data["dinning"] = this.dinning;
        data["rent"] = this.rent;
        data["rentValue"] = this.rentValue;
        data["diningRoom"] = this.diningRoom;
        if (Array.isArray(this.facilites)) {
            data["facilites"] = [];
            for (let item of this.facilites)
                data["facilites"].push(item.toJSON());
        }
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item);
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item);
        }
        data["decoration"] = this.decoration;
        data["document"] = this.document;
        data["viewsCount"] = this.viewsCount;
        data["agreementStatus"] = this.agreementStatus;
        data["agreementStatusId"] = this.agreementStatusId;
        data["furnished"] = this.furnished;
        data["elevator"] = this.elevator;
        data["parking"] = this.parking;
        data["propertyFor"] = this.propertyFor;
        data["chaletRentType"] = this.chaletRentType;
        data["chaletRentTypeString"] = this.chaletRentTypeString;
        data["numOfMonths"] = this.numOfMonths;
        data["chaletRentValue"] = this.chaletRentValue;
        data["minTimeToBookForChaletId"] = this.minTimeToBookForChaletId;
        data["minTimeToBookName"] = this.minTimeToBookName;
        data["showChalet"] = this.showChalet;
        data["officies"] = this.officies;
        if (Array.isArray(this.advertisementBookings)) {
            data["advertisementBookings"] = [];
            for (let item of this.advertisementBookings)
                data["advertisementBookings"].push(item.toISOString());
        }
        data["downPayment"] = this.downPayment;
        data["monthlyInstallment"] = this.monthlyInstallment;
        data["yearlyInstallment"] = this.yearlyInstallment;
        data["numOfYears"] = this.numOfYears;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["isEdited"] = this.isEdited;
        data["isCompany"] = this.isCompany;
        data["companyLogo"] = this.companyLogo;
        data["companyAbout"] = this.companyAbout;
        data["companyFacebook"] = this.companyFacebook;
        data["companyInstagram"] = this.companyInstagram;
        data["companySnapchat"] = this.companySnapchat;
        data["companyTiktok"] = this.companyTiktok;
        data["companyWebsite"] = this.companyWebsite;
        data["companyName"] = this.companyName;
        data["companyLatitude"] = this.companyLatitude;
        data["companyLongitude"] = this.companyLongitude;
        data["projectName"] = this.projectName;
        return data;
    }

    clone(): ApiGetAdvertiseDto {
        const json = this.toJSON();
        let result = new ApiGetAdvertiseDto();
        result.init(json);
        return result;
    }
}

export interface IApiGetAdvertiseDto {
    id: number;
    title: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    governorateName: string | undefined;
    compound: string | undefined;
    street: string | undefined;
    buildingNumber: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    floorsNumber: number | undefined;
    area: string | undefined;
    buildingArea: number | undefined;
    chaletType: ChaletType;
    buildingStatus: string | undefined;
    landingStatus: string | undefined;
    usingFor: UsingFor;
    usingForString: string | undefined;
    streetWidth: number | undefined;
    width: number | undefined;
    length: number | undefined;
    buildingDate: moment.Moment | undefined;
    rooms: number | undefined;
    reception: number | undefined;
    balcony: number | undefined;
    kitchen: number | undefined;
    toilet: number | undefined;
    numUnits: number | undefined;
    numPartitions: number | undefined;
    officesNum: number | undefined;
    officesFloors: number | undefined;
    durationId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
    brokerPersonId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    description: string | undefined;
    featuredAd: boolean | undefined;
    price: string | undefined;
    paymentFacility: PaymentFacilitiesType;
    advertiseMakerName: string | undefined;
    advertiseMaker: string | undefined;
    mobileNumber: string | undefined;
    isWhatsApped: string | undefined;
    whatsApped: boolean | undefined;
    secondMobileNumber: string | undefined;
    contactRegisterInTheAccount: boolean;
    parkingSpace: number | undefined;
    garden: string | undefined;
    gardenArea: number | undefined;
    pool: string | undefined;
    shop: string | undefined;
    shopsNumber: number | undefined;
    dinning: number | undefined;
    rent: RentType;
    rentValue: string | undefined;
    diningRoom: string | undefined;
    facilites: FacilityDtoApi[] | undefined;
    photos: string[] | undefined;
    layouts: string[] | undefined;
    decoration: string | undefined;
    document: string | undefined;
    viewsCount: number | undefined;
    agreementStatus: string | undefined;
    agreementStatusId: AgreementStatus;
    furnished: string | undefined;
    elevator: string | undefined;
    parking: string | undefined;
    propertyFor: string | undefined;
    chaletRentType: ChaletRentType;
    chaletRentTypeString: string | undefined;
    numOfMonths: number | undefined;
    chaletRentValue: number | undefined;
    minTimeToBookForChaletId: number | undefined;
    minTimeToBookName: string | undefined;
    showChalet: boolean | undefined;
    officies: OfficiesType;
    advertisementBookings: moment.Moment[] | undefined;
    downPayment: number | undefined;
    monthlyInstallment: number | undefined;
    yearlyInstallment: number | undefined;
    numOfYears: number | undefined;
    deliveryDate: moment.Moment | undefined;
    isEdited: boolean | undefined;
    isCompany: boolean;
    companyLogo: string | undefined;
    companyAbout: string | undefined;
    companyFacebook: string | undefined;
    companyInstagram: string | undefined;
    companySnapchat: string | undefined;
    companyTiktok: string | undefined;
    companyWebsite: string | undefined;
    companyName: string | undefined;
    companyLatitude: number | undefined;
    companyLongitude: number | undefined;
    projectName: string | undefined;
}

export class ApiGovernorateDto implements IApiGovernorateDto {
    id: number;
    name: string | undefined;

    constructor(data?: IApiGovernorateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ApiGovernorateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiGovernorateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ApiGovernorateDto {
        const json = this.toJSON();
        let result = new ApiGovernorateDto();
        result.init(json);
        return result;
    }
}

export interface IApiGovernorateDto {
    id: number;
    name: string | undefined;
}

export class ApiNotificationsForUserInput implements IApiNotificationsForUserInput {
    userId: number | undefined;

    constructor(data?: IApiNotificationsForUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ApiNotificationsForUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiNotificationsForUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }

    clone(): ApiNotificationsForUserInput {
        const json = this.toJSON();
        let result = new ApiNotificationsForUserInput();
        result.init(json);
        return result;
    }
}

export interface IApiNotificationsForUserInput {
    userId: number | undefined;
}

export class ApiOwnerDetailsDto implements IApiOwnerDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;

    constructor(data?: IApiOwnerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secondMobile = _data["secondMobile"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): ApiOwnerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiOwnerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secondMobile"] = this.secondMobile;
        data["isWhatsApped"] = this.isWhatsApped;
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["avatar"] = this.avatar;
        return data;
    }

    clone(): ApiOwnerDetailsDto {
        const json = this.toJSON();
        let result = new ApiOwnerDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IApiOwnerDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
}

export class ApiOwnerDetailsDtoOut implements IApiOwnerDetailsDtoOut {
    details: ApiOwnerDetailsDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiOwnerDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiOwnerDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiOwnerDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiOwnerDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiOwnerDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiOwnerDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiOwnerDetailsDtoOut {
    details: ApiOwnerDetailsDto;
    success: boolean;
    error: string | undefined;
}

export class ApiPackageDto implements IApiPackageDto {
    id: number;
    name: string | undefined;
    price: number | undefined;
    points: number | undefined;

    constructor(data?: IApiPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.points = _data["points"];
        }
    }

    static fromJS(data: any): ApiPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["points"] = this.points;
        return data;
    }

    clone(): ApiPackageDto {
        const json = this.toJSON();
        let result = new ApiPackageDto();
        result.init(json);
        return result;
    }
}

export interface IApiPackageDto {
    id: number;
    name: string | undefined;
    price: number | undefined;
    points: number | undefined;
}

export class ApiPlaceDurationOut implements IApiPlaceDurationOut {
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiPlaceDurationOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiPlaceDurationOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiPlaceDurationOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiPlaceDurationOut {
        const json = this.toJSON();
        let result = new ApiPlaceDurationOut();
        result.init(json);
        return result;
    }
}

export interface IApiPlaceDurationOut {
    success: boolean;
    error: string | undefined;
}

export class ApiProjectDetailsDtoOut implements IApiProjectDetailsDtoOut {
    details: ApiProjectDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiProjectDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiProjectDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiProjectDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProjectDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiProjectDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiProjectDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiProjectDetailsDtoOut {
    details: ApiProjectDto;
    success: boolean;
    error: string | undefined;
}

export class ApiProjectDetailsInput implements IApiProjectDetailsInput {
    projectId: number | undefined;

    constructor(data?: IApiProjectDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ApiProjectDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProjectDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): ApiProjectDetailsInput {
        const json = this.toJSON();
        let result = new ApiProjectDetailsInput();
        result.init(json);
        return result;
    }
}

export interface IApiProjectDetailsInput {
    projectId: number | undefined;
}

export class ApiProjectDto implements IApiProjectDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    durationId: number | undefined;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisements: ApiCreateAdvertisementDto[] | undefined;

    constructor(data?: IApiProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.durationId = _data["durationId"];
            this.featuredAd = _data["featuredAd"];
            this.companyId = _data["companyId"];
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            if (Array.isArray(_data["photosList"])) {
                this.photosList = [] as any;
                for (let item of _data["photosList"])
                    this.photosList.push(item);
            }
            if (Array.isArray(_data["layoutsList"])) {
                this.layoutsList = [] as any;
                for (let item of _data["layoutsList"])
                    this.layoutsList.push(item);
            }
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(ApiCreateAdvertisementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["durationId"] = this.durationId;
        data["featuredAd"] = this.featuredAd;
        data["companyId"] = this.companyId;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        if (Array.isArray(this.photosList)) {
            data["photosList"] = [];
            for (let item of this.photosList)
                data["photosList"].push(item);
        }
        if (Array.isArray(this.layoutsList)) {
            data["layoutsList"] = [];
            for (let item of this.layoutsList)
                data["layoutsList"].push(item);
        }
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApiProjectDto {
        const json = this.toJSON();
        let result = new ApiProjectDto();
        result.init(json);
        return result;
    }
}

export interface IApiProjectDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    durationId: number | undefined;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    isPublish: boolean;
    isApprove: boolean | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisements: ApiCreateAdvertisementDto[] | undefined;
}

export class ApiProjectInput implements IApiProjectInput {
    keyword: string | undefined;
    userId: number | undefined;
    companyId: number | undefined;

    constructor(data?: IApiProjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.userId = _data["userId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): ApiProjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["userId"] = this.userId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): ApiProjectInput {
        const json = this.toJSON();
        let result = new ApiProjectInput();
        result.init(json);
        return result;
    }
}

export interface IApiProjectInput {
    keyword: string | undefined;
    userId: number | undefined;
    companyId: number | undefined;
}

export class ApiProjectOut implements IApiProjectOut {
    projectId: number | undefined;
    project: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiProjectOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiProjectOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProjectOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiProjectOut {
        const json = this.toJSON();
        let result = new ApiProjectOut();
        result.init(json);
        return result;
    }
}

export interface IApiProjectOut {
    projectId: number | undefined;
    project: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiRateDto implements IApiRateDto {
    id: number;
    userId: number;
    userRate: number;

    constructor(data?: IApiRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userRate = _data["userRate"];
        }
    }

    static fromJS(data: any): ApiRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userRate"] = this.userRate;
        return data;
    }

    clone(): ApiRateDto {
        const json = this.toJSON();
        let result = new ApiRateDto();
        result.init(json);
        return result;
    }
}

export interface IApiRateDto {
    id: number;
    userId: number;
    userRate: number;
}

export class ApiSeekerDetailsDto implements IApiSeekerDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;

    constructor(data?: IApiSeekerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secondMobile = _data["secondMobile"];
            this.isWhatsApped = _data["isWhatsApped"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): ApiSeekerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSeekerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secondMobile"] = this.secondMobile;
        data["isWhatsApped"] = this.isWhatsApped;
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["avatar"] = this.avatar;
        return data;
    }

    clone(): ApiSeekerDetailsDto {
        const json = this.toJSON();
        let result = new ApiSeekerDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IApiSeekerDetailsDto {
    secondMobile: string | undefined;
    isWhatsApped: boolean;
    id: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
}

export class ApiSeekerDetailsDtoOut implements IApiSeekerDetailsDtoOut {
    details: ApiSeekerDetailsDto;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiSeekerDetailsDtoOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ApiSeekerDetailsDto.fromJS(_data["details"]) : <any>undefined;
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiSeekerDetailsDtoOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSeekerDetailsDtoOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiSeekerDetailsDtoOut {
        const json = this.toJSON();
        let result = new ApiSeekerDetailsDtoOut();
        result.init(json);
        return result;
    }
}

export interface IApiSeekerDetailsDtoOut {
    details: ApiSeekerDetailsDto;
    success: boolean;
    error: string | undefined;
}

export class ApiSocialContactDto implements IApiSocialContactDto {
    socialName: string | undefined;
    socialValue: string | undefined;
    avatar: string | undefined;

    constructor(data?: IApiSocialContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socialName = _data["socialName"];
            this.socialValue = _data["socialValue"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): ApiSocialContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSocialContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socialName"] = this.socialName;
        data["socialValue"] = this.socialValue;
        data["avatar"] = this.avatar;
        return data;
    }

    clone(): ApiSocialContactDto {
        const json = this.toJSON();
        let result = new ApiSocialContactDto();
        result.init(json);
        return result;
    }
}

export interface IApiSocialContactDto {
    socialName: string | undefined;
    socialValue: string | undefined;
    avatar: string | undefined;
}

export class ApiSponsorDto implements IApiSponsorDto {
    id: number;
    secondMobile: string | undefined;
    userId: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    photo: string | undefined;

    constructor(data?: IApiSponsorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.secondMobile = _data["secondMobile"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.photo = _data["photo"];
        }
    }

    static fromJS(data: any): ApiSponsorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSponsorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["secondMobile"] = this.secondMobile;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["photo"] = this.photo;
        return data;
    }

    clone(): ApiSponsorDto {
        const json = this.toJSON();
        let result = new ApiSponsorDto();
        result.init(json);
        return result;
    }
}

export interface IApiSponsorDto {
    id: number;
    secondMobile: string | undefined;
    userId: number | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    photo: string | undefined;
}

export class ApiUpdateAdvertisementBookingDto implements IApiUpdateAdvertisementBookingDto {
    id: number;
    bookingDate: moment.Moment;
    advertisementId: number;

    constructor(data?: IApiUpdateAdvertisementBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bookingDate = _data["bookingDate"] ? moment(_data["bookingDate"].toString()) : <any>undefined;
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): ApiUpdateAdvertisementBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateAdvertisementBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bookingDate"] = this.bookingDate ? this.bookingDate.toISOString() : <any>undefined;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): ApiUpdateAdvertisementBookingDto {
        const json = this.toJSON();
        let result = new ApiUpdateAdvertisementBookingDto();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateAdvertisementBookingDto {
    id: number;
    bookingDate: moment.Moment;
    advertisementId: number;
}

export class ApiUpdateAdvertisementBookingOut implements IApiUpdateAdvertisementBookingOut {
    advertisementBookingId: number | undefined;
    advertisementBooking: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUpdateAdvertisementBookingOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementBookingId = _data["advertisementBookingId"];
            this.advertisementBooking = _data["advertisementBooking"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUpdateAdvertisementBookingOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateAdvertisementBookingOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementBookingId"] = this.advertisementBookingId;
        data["advertisementBooking"] = this.advertisementBooking;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUpdateAdvertisementBookingOut {
        const json = this.toJSON();
        let result = new ApiUpdateAdvertisementBookingOut();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateAdvertisementBookingOut {
    advertisementBookingId: number | undefined;
    advertisementBooking: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUpdateBrokerPersonDto implements IApiUpdateBrokerPersonDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;

    constructor(data?: IApiUpdateBrokerPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.packageId = _data["packageId"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ApiUpdateBrokerPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateBrokerPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["packageId"] = this.packageId;
        data["balance"] = this.balance;
        return data;
    }

    clone(): ApiUpdateBrokerPersonDto {
        const json = this.toJSON();
        let result = new ApiUpdateBrokerPersonDto();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateBrokerPersonDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;
}

export class ApiUpdateBrokerPersonOut implements IApiUpdateBrokerPersonOut {
    brokerPersonId: number | undefined;
    brokerPerson: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUpdateBrokerPersonOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brokerPersonId = _data["brokerPersonId"];
            this.brokerPerson = _data["brokerPerson"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUpdateBrokerPersonOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateBrokerPersonOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerPersonId"] = this.brokerPersonId;
        data["brokerPerson"] = this.brokerPerson;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUpdateBrokerPersonOut {
        const json = this.toJSON();
        let result = new ApiUpdateBrokerPersonOut();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateBrokerPersonOut {
    brokerPersonId: number | undefined;
    brokerPerson: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUpdateCompanyDto implements IApiUpdateCompanyDto {
    id: number;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;

    constructor(data?: IApiUpdateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.secondMobile = _data["secondMobile"];
            this.logo = _data["logo"];
            this.bwLogo = _data["bwLogo"];
            this.commericalAvatar = _data["commericalAvatar"];
            this.about = _data["about"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.snapchat = _data["snapchat"];
            this.tiktok = _data["tiktok"];
            this.website = _data["website"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.packageId = _data["packageId"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ApiUpdateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["secondMobile"] = this.secondMobile;
        data["logo"] = this.logo;
        data["bwLogo"] = this.bwLogo;
        data["commericalAvatar"] = this.commericalAvatar;
        data["about"] = this.about;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["snapchat"] = this.snapchat;
        data["tiktok"] = this.tiktok;
        data["website"] = this.website;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["packageId"] = this.packageId;
        data["balance"] = this.balance;
        return data;
    }

    clone(): ApiUpdateCompanyDto {
        const json = this.toJSON();
        let result = new ApiUpdateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateCompanyDto {
    id: number;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;
}

export class ApiUpdateCompanyOut implements IApiUpdateCompanyOut {
    companyId: number | undefined;
    company: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUpdateCompanyOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.company = _data["company"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUpdateCompanyOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateCompanyOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["company"] = this.company;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUpdateCompanyOut {
        const json = this.toJSON();
        let result = new ApiUpdateCompanyOut();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateCompanyOut {
    companyId: number | undefined;
    company: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUpdateOwnerDto implements IApiUpdateOwnerDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;

    constructor(data?: IApiUpdateOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.packageId = _data["packageId"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ApiUpdateOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["packageId"] = this.packageId;
        data["balance"] = this.balance;
        return data;
    }

    clone(): ApiUpdateOwnerDto {
        const json = this.toJSON();
        let result = new ApiUpdateOwnerDto();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateOwnerDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;
}

export class ApiUpdateOwnerOut implements IApiUpdateOwnerOut {
    ownerId: number | undefined;
    owner: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUpdateOwnerOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUpdateOwnerOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateOwnerOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUpdateOwnerOut {
        const json = this.toJSON();
        let result = new ApiUpdateOwnerOut();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateOwnerOut {
    ownerId: number | undefined;
    owner: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUpdateSeekerDto implements IApiUpdateSeekerDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;

    constructor(data?: IApiUpdateSeekerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.packageId = _data["packageId"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ApiUpdateSeekerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateSeekerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["packageId"] = this.packageId;
        data["balance"] = this.balance;
        return data;
    }

    clone(): ApiUpdateSeekerDto {
        const json = this.toJSON();
        let result = new ApiUpdateSeekerDto();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateSeekerDto {
    id: number;
    secondMobile: string | undefined;
    avatar: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    packageId: number | undefined;
    balance: number | undefined;
}

export class ApiUpdateSeekerOut implements IApiUpdateSeekerOut {
    seekerId: number | undefined;
    seeker: any | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUpdateSeekerOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seekerId = _data["seekerId"];
            this.seeker = _data["seeker"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUpdateSeekerOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUpdateSeekerOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seekerId"] = this.seekerId;
        data["seeker"] = this.seeker;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUpdateSeekerOut {
        const json = this.toJSON();
        let result = new ApiUpdateSeekerOut();
        result.init(json);
        return result;
    }
}

export interface IApiUpdateSeekerOut {
    seekerId: number | undefined;
    seeker: any | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUserAdsDto implements IApiUserAdsDto {
    id: number;
    title: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    isPublish: boolean;
    isApproved: boolean | undefined;
    viewCount: number | undefined;
    photos: string[] | undefined;
    type: string | undefined;
    typeId: BuildingType;
    expireStatus: ExpiredStatus;

    constructor(data?: IApiUserAdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.isApproved = _data["isApproved"];
            this.viewCount = _data["viewCount"];
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(item);
            }
            this.type = _data["type"];
            this.typeId = _data["typeId"];
            this.expireStatus = _data["expireStatus"];
        }
    }

    static fromJS(data: any): ApiUserAdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUserAdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["isApproved"] = this.isApproved;
        data["viewCount"] = this.viewCount;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item);
        }
        data["type"] = this.type;
        data["typeId"] = this.typeId;
        data["expireStatus"] = this.expireStatus;
        return data;
    }

    clone(): ApiUserAdsDto {
        const json = this.toJSON();
        let result = new ApiUserAdsDto();
        result.init(json);
        return result;
    }
}

export interface IApiUserAdsDto {
    id: number;
    title: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    isPublish: boolean;
    isApproved: boolean | undefined;
    viewCount: number | undefined;
    photos: string[] | undefined;
    type: string | undefined;
    typeId: BuildingType;
    expireStatus: ExpiredStatus;
}

export class ApiUserAdsOut implements IApiUserAdsOut {
    advertisements: ApiUserAdsDto[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUserAdsOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(ApiUserAdsDto.fromJS(item));
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUserAdsOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUserAdsOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUserAdsOut {
        const json = this.toJSON();
        let result = new ApiUserAdsOut();
        result.init(json);
        return result;
    }
}

export interface IApiUserAdsOut {
    advertisements: ApiUserAdsDto[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiUserNotificationDto implements IApiUserNotificationDto {
    id: number;
    description: string | undefined;
    date: string | undefined;

    constructor(data?: IApiUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.date = _data["date"];
        }
    }

    static fromJS(data: any): ApiUserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["date"] = this.date;
        return data;
    }

    clone(): ApiUserNotificationDto {
        const json = this.toJSON();
        let result = new ApiUserNotificationDto();
        result.init(json);
        return result;
    }
}

export interface IApiUserNotificationDto {
    id: number;
    description: string | undefined;
    date: string | undefined;
}

export class ApiUserNotificationsOut implements IApiUserNotificationsOut {
    notifications: ApiUserNotificationDto[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiUserNotificationsOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications.push(ApiUserNotificationDto.fromJS(item));
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiUserNotificationsOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiUserNotificationsOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiUserNotificationsOut {
        const json = this.toJSON();
        let result = new ApiUserNotificationsOut();
        result.init(json);
        return result;
    }
}

export interface IApiUserNotificationsOut {
    notifications: ApiUserNotificationDto[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiViewForChartInput implements IApiViewForChartInput {
    advertisementId: number;
    durationByDays: number;
    interval: number;

    constructor(data?: IApiViewForChartInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementId = _data["advertisementId"];
            this.durationByDays = _data["durationByDays"];
            this.interval = _data["interval"];
        }
    }

    static fromJS(data: any): ApiViewForChartInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiViewForChartInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementId"] = this.advertisementId;
        data["durationByDays"] = this.durationByDays;
        data["interval"] = this.interval;
        return data;
    }

    clone(): ApiViewForChartInput {
        const json = this.toJSON();
        let result = new ApiViewForChartInput();
        result.init(json);
        return result;
    }
}

export interface IApiViewForChartInput {
    advertisementId: number;
    durationByDays: number;
    interval: number;
}

export class ApiViewForChartOut implements IApiViewForChartOut {
    counts: number[] | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiViewForChartOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["counts"])) {
                this.counts = [] as any;
                for (let item of _data["counts"])
                    this.counts.push(item);
            }
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiViewForChartOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiViewForChartOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.counts)) {
            data["counts"] = [];
            for (let item of this.counts)
                data["counts"].push(item);
        }
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiViewForChartOut {
        const json = this.toJSON();
        let result = new ApiViewForChartOut();
        result.init(json);
        return result;
    }
}

export interface IApiViewForChartOut {
    counts: number[] | undefined;
    success: boolean;
    error: string | undefined;
}

export class ApiViewInput implements IApiViewInput {
    advertisementId: number;

    constructor(data?: IApiViewInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): ApiViewInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApiViewInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): ApiViewInput {
        const json = this.toJSON();
        let result = new ApiViewInput();
        result.init(json);
        return result;
    }
}

export interface IApiViewInput {
    advertisementId: number;
}

export class ApiViewOut implements IApiViewOut {
    count: number;
    success: boolean;
    error: string | undefined;

    constructor(data?: IApiViewOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ApiViewOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiViewOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): ApiViewOut {
        const json = this.toJSON();
        let result = new ApiViewOut();
        result.init(json);
        return result;
    }
}

export interface IApiViewOut {
    count: number;
    success: boolean;
    error: string | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export enum ApprovalStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    registrationDevice: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.registrationDevice = _data["registrationDevice"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["registrationDevice"] = this.registrationDevice;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    registrationDevice: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    loginType: LoginType;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.loginType = _data["loginType"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["loginType"] = this.loginType;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    loginType: LoginType;
}

export class BrokerPerson implements IBrokerPerson {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;

    constructor(data?: IBrokerPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? Package.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): BrokerPerson {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): BrokerPerson {
        const json = this.toJSON();
        let result = new BrokerPerson();
        result.init(json);
        return result;
    }
}

export interface IBrokerPerson {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;
}

export class BrokerPersonDto implements IBrokerPersonDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;

    constructor(data?: IBrokerPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.aboutAr = _data["aboutAr"];
            this.aboutEn = _data["aboutEn"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? PackageDto.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): BrokerPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["aboutAr"] = this.aboutAr;
        data["aboutEn"] = this.aboutEn;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): BrokerPersonDto {
        const json = this.toJSON();
        let result = new BrokerPersonDto();
        result.init(json);
        return result;
    }
}

export interface IBrokerPersonDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;
}

export class BrokerPersonDtoDataTableOutputDto implements IBrokerPersonDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: BrokerPersonDto[] | undefined;

    constructor(data?: IBrokerPersonDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(BrokerPersonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerPersonDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerPersonDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): BrokerPersonDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new BrokerPersonDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IBrokerPersonDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: BrokerPersonDto[] | undefined;
}

export class BrokerPersonLoginInfoDto implements IBrokerPersonLoginInfoDto {
    id: number;
    name: string | undefined;

    constructor(data?: IBrokerPersonLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BrokerPersonLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerPersonLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): BrokerPersonLoginInfoDto {
        const json = this.toJSON();
        let result = new BrokerPersonLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IBrokerPersonLoginInfoDto {
    id: number;
    name: string | undefined;
}

export enum BuildingStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum BuildingType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum ChaletRentType {
    _1 = 1,
    _2 = 2,
}

export enum ChaletType {
    _1 = 1,
    _2 = 2,
}

export class ChangeAdStatusOutput implements IChangeAdStatusOutput {
    advertiseID: number | undefined;
    activeStatus: boolean | undefined;
    message: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IChangeAdStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.advertiseID = _data["advertiseID"];
            this.activeStatus = _data["activeStatus"];
            this.message = _data["message"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ChangeAdStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeAdStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertiseID"] = this.advertiseID;
        data["activeStatus"] = this.activeStatus;
        data["message"] = this.message;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): ChangeAdStatusOutput {
        const json = this.toJSON();
        let result = new ChangeAdStatusOutput();
        result.init(json);
        return result;
    }
}

export interface IChangeAdStatusOutput {
    advertiseID: number | undefined;
    activeStatus: boolean | undefined;
    message: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CheckDeviceInput implements ICheckDeviceInput {
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;

    constructor(data?: ICheckDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.deviceName = _data["deviceName"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): CheckDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        return data;
    }

    clone(): CheckDeviceInput {
        const json = this.toJSON();
        let result = new CheckDeviceInput();
        result.init(json);
        return result;
    }
}

export interface ICheckDeviceInput {
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;
}

export class CheckRegisteredDeviceInput implements ICheckRegisteredDeviceInput {
    registrationToken: string;
    type: DeviceTypes;
    osVersion: string | undefined;
    userId: number | undefined;
    checkForUnique: boolean;

    constructor(data?: ICheckRegisteredDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationToken = _data["registrationToken"];
            this.type = _data["type"];
            this.osVersion = _data["osVersion"];
            this.userId = _data["userId"];
            this.checkForUnique = _data["checkForUnique"];
        }
    }

    static fromJS(data: any): CheckRegisteredDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRegisteredDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationToken"] = this.registrationToken;
        data["type"] = this.type;
        data["osVersion"] = this.osVersion;
        data["userId"] = this.userId;
        data["checkForUnique"] = this.checkForUnique;
        return data;
    }

    clone(): CheckRegisteredDeviceInput {
        const json = this.toJSON();
        let result = new CheckRegisteredDeviceInput();
        result.init(json);
        return result;
    }
}

export interface ICheckRegisteredDeviceInput {
    registrationToken: string;
    type: DeviceTypes;
    osVersion: string | undefined;
    userId: number | undefined;
    checkForUnique: boolean;
}

export class CheckStatusOutput implements ICheckStatusOutput {
    status: boolean;
    error: string | undefined;
    success: boolean;

    constructor(data?: ICheckStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CheckStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): CheckStatusOutput {
        const json = this.toJSON();
        let result = new CheckStatusOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckStatusOutput {
    status: boolean;
    error: string | undefined;
    success: boolean;
}

export class City implements ICity {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    governorateId: number;
    governorate: Governorate;
    isEnabled: boolean;

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.governorateId = _data["governorateId"];
            this.governorate = _data["governorate"] ? Governorate.fromJS(_data["governorate"]) : <any>undefined;
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["governorateId"] = this.governorateId;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        return data;
    }

    clone(): City {
        const json = this.toJSON();
        let result = new City();
        result.init(json);
        return result;
    }
}

export interface ICity {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    governorateId: number;
    governorate: Governorate;
    isEnabled: boolean;
}

export class CityDto implements ICityDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    governorateId: number;
    governorate: GovernorateDto;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.governorateId = _data["governorateId"];
            this.governorate = _data["governorate"] ? GovernorateDto.fromJS(_data["governorate"]) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.isEnabled = _data["isEnabled"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["governorateId"] = this.governorateId;
        data["governorate"] = this.governorate ? this.governorate.toJSON() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): CityDto {
        const json = this.toJSON();
        let result = new CityDto();
        result.init(json);
        return result;
    }
}

export interface ICityDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    governorateId: number;
    governorate: GovernorateDto;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class CityDtoDataTableOutputDto implements ICityDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CityDto[] | undefined;

    constructor(data?: ICityDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(CityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CityDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): CityDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new CityDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICityDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CityDto[] | undefined;
}

export class CityDtoPagedResultDto implements ICityDtoPagedResultDto {
    items: CityDto[] | undefined;
    totalCount: number;

    constructor(data?: ICityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CityDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICityDtoPagedResultDto {
    items: CityDto[] | undefined;
    totalCount: number;
}

export class Color implements IColor {
    readonly r: number;
    readonly g: number;
    readonly b: number;
    readonly a: number;
    readonly isKnownColor: boolean;
    readonly isEmpty: boolean;
    readonly isNamedColor: boolean;
    readonly isSystemColor: boolean;
    readonly name: string | undefined;

    constructor(data?: IColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).r = _data["r"];
            (<any>this).g = _data["g"];
            (<any>this).b = _data["b"];
            (<any>this).a = _data["a"];
            (<any>this).isKnownColor = _data["isKnownColor"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).isNamedColor = _data["isNamedColor"];
            (<any>this).isSystemColor = _data["isSystemColor"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): Color {
        data = typeof data === 'object' ? data : {};
        let result = new Color();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["r"] = this.r;
        data["g"] = this.g;
        data["b"] = this.b;
        data["a"] = this.a;
        data["isKnownColor"] = this.isKnownColor;
        data["isEmpty"] = this.isEmpty;
        data["isNamedColor"] = this.isNamedColor;
        data["isSystemColor"] = this.isSystemColor;
        data["name"] = this.name;
        return data;
    }

    clone(): Color {
        const json = this.toJSON();
        let result = new Color();
        result.init(json);
        return result;
    }
}

export interface IColor {
    r: number;
    g: number;
    b: number;
    a: number;
    isKnownColor: boolean;
    isEmpty: boolean;
    isNamedColor: boolean;
    isSystemColor: boolean;
    name: string | undefined;
}

export class ColorPalette implements IColorPalette {
    readonly flags: number;
    readonly entries: Color[] | undefined;

    constructor(data?: IColorPalette) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).flags = _data["flags"];
            if (Array.isArray(_data["entries"])) {
                (<any>this).entries = [] as any;
                for (let item of _data["entries"])
                    (<any>this).entries.push(Color.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColorPalette {
        data = typeof data === 'object' ? data : {};
        let result = new ColorPalette();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flags"] = this.flags;
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }

    clone(): ColorPalette {
        const json = this.toJSON();
        let result = new ColorPalette();
        result.init(json);
        return result;
    }
}

export interface IColorPalette {
    flags: number;
    entries: Color[] | undefined;
}

export class Column implements IColumn {
    name: string | undefined;
    orderable: boolean;
    searchable: boolean;
    search: Search;

    constructor(data?: IColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderable = _data["orderable"];
            this.searchable = _data["searchable"];
            this.search = _data["search"] ? Search.fromJS(_data["search"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Column {
        data = typeof data === 'object' ? data : {};
        let result = new Column();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderable"] = this.orderable;
        data["searchable"] = this.searchable;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        return data;
    }

    clone(): Column {
        const json = this.toJSON();
        let result = new Column();
        result.init(json);
        return result;
    }
}

export interface IColumn {
    name: string | undefined;
    orderable: boolean;
    searchable: boolean;
    search: Search;
}

export class Company implements ICompany {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    isSponser: boolean;
    isActive: boolean;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.isSponser = _data["isSponser"];
            this.isActive = _data["isActive"];
            this.secondMobile = _data["secondMobile"];
            this.logo = _data["logo"];
            this.bwLogo = _data["bwLogo"];
            this.commericalAvatar = _data["commericalAvatar"];
            this.about = _data["about"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.snapchat = _data["snapchat"];
            this.tiktok = _data["tiktok"];
            this.website = _data["website"];
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? Package.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["isSponser"] = this.isSponser;
        data["isActive"] = this.isActive;
        data["secondMobile"] = this.secondMobile;
        data["logo"] = this.logo;
        data["bwLogo"] = this.bwLogo;
        data["commericalAvatar"] = this.commericalAvatar;
        data["about"] = this.about;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["snapchat"] = this.snapchat;
        data["tiktok"] = this.tiktok;
        data["website"] = this.website;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    isSponser: boolean;
    isActive: boolean;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;
}

export class CompanyDto implements ICompanyDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    isSponser: boolean;
    isActive: boolean;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.isSponser = _data["isSponser"];
            this.isActive = _data["isActive"];
            this.secondMobile = _data["secondMobile"];
            this.logo = _data["logo"];
            this.bwLogo = _data["bwLogo"];
            this.commericalAvatar = _data["commericalAvatar"];
            this.about = _data["about"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.snapchat = _data["snapchat"];
            this.tiktok = _data["tiktok"];
            this.website = _data["website"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.aboutAr = _data["aboutAr"];
            this.aboutEn = _data["aboutEn"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? PackageDto.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["isSponser"] = this.isSponser;
        data["isActive"] = this.isActive;
        data["secondMobile"] = this.secondMobile;
        data["logo"] = this.logo;
        data["bwLogo"] = this.bwLogo;
        data["commericalAvatar"] = this.commericalAvatar;
        data["about"] = this.about;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["snapchat"] = this.snapchat;
        data["tiktok"] = this.tiktok;
        data["website"] = this.website;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["aboutAr"] = this.aboutAr;
        data["aboutEn"] = this.aboutEn;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    isSponser: boolean;
    isActive: boolean;
    secondMobile: string | undefined;
    logo: string | undefined;
    bwLogo: string | undefined;
    commericalAvatar: string | undefined;
    about: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    facebook: string | undefined;
    instagram: string | undefined;
    snapchat: string | undefined;
    tiktok: string | undefined;
    website: string | undefined;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;
}

export class CompanyDtoDataTableOutputDto implements ICompanyDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CompanyDto[] | undefined;

    constructor(data?: ICompanyDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(CompanyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanyDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new CompanyDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CompanyDto[] | undefined;
}

export class CompanyLoginInfoDto implements ICompanyLoginInfoDto {
    id: number;
    name: string | undefined;

    constructor(data?: ICompanyLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanyLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CompanyLoginInfoDto {
        const json = this.toJSON();
        let result = new CompanyLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyLoginInfoDto {
    id: number;
    name: string | undefined;
}

export class CompanyPackageTransactionDto implements ICompanyPackageTransactionDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    subscribeDate: moment.Moment;
    packageId: number;
    package: PackageDto;
    companyId: number;
    company: CompanyDto;

    constructor(data?: ICompanyPackageTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.subscribeDate = _data["subscribeDate"] ? moment(_data["subscribeDate"].toString()) : <any>undefined;
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? PackageDto.fromJS(_data["package"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyPackageTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyPackageTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["subscribeDate"] = this.subscribeDate ? this.subscribeDate.toISOString() : <any>undefined;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): CompanyPackageTransactionDto {
        const json = this.toJSON();
        let result = new CompanyPackageTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyPackageTransactionDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    subscribeDate: moment.Moment;
    packageId: number;
    package: PackageDto;
    companyId: number;
    company: CompanyDto;
}

export class CompanyPackageTransactionDtoPagedResultDto implements ICompanyPackageTransactionDtoPagedResultDto {
    items: CompanyPackageTransactionDto[] | undefined;
    totalCount: number;

    constructor(data?: ICompanyPackageTransactionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CompanyPackageTransactionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyPackageTransactionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyPackageTransactionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CompanyPackageTransactionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyPackageTransactionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyPackageTransactionDtoPagedResultDto {
    items: CompanyPackageTransactionDto[] | undefined;
    totalCount: number;
}

export class ContactUsDto implements IContactUsDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    emailAddress: string | undefined;
    emailSubject: string | undefined;
    attachmentPath: string | undefined;
    userId: number | undefined;
    user: UserDto;

    constructor(data?: IContactUsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.emailAddress = _data["emailAddress"];
            this.emailSubject = _data["emailSubject"];
            this.attachmentPath = _data["attachmentPath"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["emailAddress"] = this.emailAddress;
        data["emailSubject"] = this.emailSubject;
        data["attachmentPath"] = this.attachmentPath;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): ContactUsDto {
        const json = this.toJSON();
        let result = new ContactUsDto();
        result.init(json);
        return result;
    }
}

export interface IContactUsDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    emailAddress: string | undefined;
    emailSubject: string | undefined;
    attachmentPath: string | undefined;
    userId: number | undefined;
    user: UserDto;
}

export class ContactUsDtoDataTableOutputDto implements IContactUsDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: ContactUsDto[] | undefined;

    constructor(data?: IContactUsDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(ContactUsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactUsDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContactUsDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new ContactUsDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IContactUsDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: ContactUsDto[] | undefined;
}

export class ContactUsDtoPagedResultDto implements IContactUsDtoPagedResultDto {
    items: ContactUsDto[] | undefined;
    totalCount: number;

    constructor(data?: IContactUsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContactUsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ContactUsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ContactUsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContactUsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContactUsDtoPagedResultDto {
    items: ContactUsDto[] | undefined;
    totalCount: number;
}

export class CountDto implements ICountDto {
    seekerCount: number;
    ownerCount: number;
    companyCount: number;
    sponsorCount: number;
    brokerCount: number;

    constructor(data?: ICountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seekerCount = _data["seekerCount"];
            this.ownerCount = _data["ownerCount"];
            this.companyCount = _data["companyCount"];
            this.sponsorCount = _data["sponsorCount"];
            this.brokerCount = _data["brokerCount"];
        }
    }

    static fromJS(data: any): CountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seekerCount"] = this.seekerCount;
        data["ownerCount"] = this.ownerCount;
        data["companyCount"] = this.companyCount;
        data["sponsorCount"] = this.sponsorCount;
        data["brokerCount"] = this.brokerCount;
        return data;
    }

    clone(): CountDto {
        const json = this.toJSON();
        let result = new CountDto();
        result.init(json);
        return result;
    }
}

export interface ICountDto {
    seekerCount: number;
    ownerCount: number;
    companyCount: number;
    sponsorCount: number;
    brokerCount: number;
}

export class Country implements ICountry {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["isEnabled"] = this.isEnabled;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;
}

export class CountryDto implements ICountryDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.isEnabled = _data["isEnabled"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isEnabled: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class CountryDtoDataTableOutputDto implements ICountryDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CountryDto[] | undefined;

    constructor(data?: ICountryDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(CountryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): CountryDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new CountryDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: CountryDto[] | undefined;
}

export class CreateNotificationsDto implements ICreateNotificationsDto {
    userId: number;
    adId: number | undefined;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    createdUserId: number | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;

    constructor(data?: ICreateNotificationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.adId = _data["adId"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.isRead = _data["isRead"];
            this.createdUserId = _data["createdUserId"];
            this.brokerId = _data["brokerId"];
            this.seekerId = _data["seekerId"];
            this.ownerId = _data["ownerId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateNotificationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["adId"] = this.adId;
        data["type"] = this.type;
        data["description"] = this.description;
        data["isRead"] = this.isRead;
        data["createdUserId"] = this.createdUserId;
        data["brokerId"] = this.brokerId;
        data["seekerId"] = this.seekerId;
        data["ownerId"] = this.ownerId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateNotificationsDto {
        const json = this.toJSON();
        let result = new CreateNotificationsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNotificationsDto {
    userId: number;
    adId: number | undefined;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    createdUserId: number | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    phoneNumber: string | undefined;
    isMobileUser: boolean;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.isMobileUser = _data["isMobileUser"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["isMobileUser"] = this.isMobileUser;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    phoneNumber: string | undefined;
    isMobileUser: boolean;
}

export enum DecorationStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Definition implements IDefinition {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    descriptionAr: string | undefined;
    descriptionEn: string | undefined;
    type: DefinitionTypes;
    avatar: string | undefined;
    value: number | undefined;

    constructor(data?: IDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionEn = _data["descriptionEn"];
            this.type = _data["type"];
            this.avatar = _data["avatar"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Definition {
        data = typeof data === 'object' ? data : {};
        let result = new Definition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionEn"] = this.descriptionEn;
        data["type"] = this.type;
        data["avatar"] = this.avatar;
        data["value"] = this.value;
        return data;
    }

    clone(): Definition {
        const json = this.toJSON();
        let result = new Definition();
        result.init(json);
        return result;
    }
}

export interface IDefinition {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    descriptionAr: string | undefined;
    descriptionEn: string | undefined;
    type: DefinitionTypes;
    avatar: string | undefined;
    value: number | undefined;
}

export class DefinitionDto implements IDefinitionDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    descriptionAr: string | undefined;
    descriptionEn: string | undefined;
    avatar: string | undefined;
    value: number | undefined;
    type: DefinitionTypes;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionEn = _data["descriptionEn"];
            this.avatar = _data["avatar"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionEn"] = this.descriptionEn;
        data["avatar"] = this.avatar;
        data["value"] = this.value;
        data["type"] = this.type;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): DefinitionDto {
        const json = this.toJSON();
        let result = new DefinitionDto();
        result.init(json);
        return result;
    }
}

export interface IDefinitionDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    descriptionAr: string | undefined;
    descriptionEn: string | undefined;
    avatar: string | undefined;
    value: number | undefined;
    type: DefinitionTypes;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class DefinitionDtoDataTableOutputDto implements IDefinitionDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DefinitionDto[] | undefined;

    constructor(data?: IDefinitionDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(DefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DefinitionDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefinitionDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DefinitionDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new DefinitionDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IDefinitionDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DefinitionDto[] | undefined;
}

export enum DefinitionTypes {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
}

export class DeleteAdOutput implements IDeleteAdOutput {
    message: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IDeleteAdOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DeleteAdOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAdOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): DeleteAdOutput {
        const json = this.toJSON();
        let result = new DeleteAdOutput();
        result.init(json);
        return result;
    }
}

export interface IDeleteAdOutput {
    message: string | undefined;
    error: string | undefined;
    success: boolean;
}

export class DeleteFavoriteOutput implements IDeleteFavoriteOutput {
    message: string | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IDeleteFavoriteOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DeleteFavoriteOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFavoriteOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): DeleteFavoriteOutput {
        const json = this.toJSON();
        let result = new DeleteFavoriteOutput();
        result.init(json);
        return result;
    }
}

export interface IDeleteFavoriteOutput {
    message: string | undefined;
    error: string | undefined;
    success: boolean;
}

export enum DeviceTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DiscountCodeDto implements IDiscountCodeDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    code: string | undefined;
    percentage: number | undefined;
    fixedAmount: number | undefined;
    isPublish: boolean;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IDiscountCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.percentage = _data["percentage"];
            this.fixedAmount = _data["fixedAmount"];
            this.isPublish = _data["isPublish"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscountCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["percentage"] = this.percentage;
        data["fixedAmount"] = this.fixedAmount;
        data["isPublish"] = this.isPublish;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): DiscountCodeDto {
        const json = this.toJSON();
        let result = new DiscountCodeDto();
        result.init(json);
        return result;
    }
}

export interface IDiscountCodeDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    code: string | undefined;
    percentage: number | undefined;
    fixedAmount: number | undefined;
    isPublish: boolean;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class DiscountCodeDtoDataTableOutputDto implements IDiscountCodeDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DiscountCodeDto[] | undefined;

    constructor(data?: IDiscountCodeDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(DiscountCodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DiscountCodeDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountCodeDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DiscountCodeDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new DiscountCodeDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IDiscountCodeDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DiscountCodeDto[] | undefined;
}

export class DiscountCodeDtoPagedResultDto implements IDiscountCodeDtoPagedResultDto {
    items: DiscountCodeDto[] | undefined;
    totalCount: number;

    constructor(data?: IDiscountCodeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DiscountCodeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DiscountCodeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountCodeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DiscountCodeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DiscountCodeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDiscountCodeDtoPagedResultDto {
    items: DiscountCodeDto[] | undefined;
    totalCount: number;
}

export enum DocumentStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Duration implements IDuration {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    period: number;
    amount: number;
    isPublish: boolean;
    durationBuildingTypes: DurationBuildingType[] | undefined;

    constructor(data?: IDuration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.period = _data["period"];
            this.amount = _data["amount"];
            this.isPublish = _data["isPublish"];
            if (Array.isArray(_data["durationBuildingTypes"])) {
                this.durationBuildingTypes = [] as any;
                for (let item of _data["durationBuildingTypes"])
                    this.durationBuildingTypes.push(DurationBuildingType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Duration {
        data = typeof data === 'object' ? data : {};
        let result = new Duration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["period"] = this.period;
        data["amount"] = this.amount;
        data["isPublish"] = this.isPublish;
        if (Array.isArray(this.durationBuildingTypes)) {
            data["durationBuildingTypes"] = [];
            for (let item of this.durationBuildingTypes)
                data["durationBuildingTypes"].push(item.toJSON());
        }
        return data;
    }

    clone(): Duration {
        const json = this.toJSON();
        let result = new Duration();
        result.init(json);
        return result;
    }
}

export interface IDuration {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    period: number;
    amount: number;
    isPublish: boolean;
    durationBuildingTypes: DurationBuildingType[] | undefined;
}

export class DurationBuildingType implements IDurationBuildingType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    durationId: number;
    duration: Duration;
    type: BuildingType;

    constructor(data?: IDurationBuildingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.durationId = _data["durationId"];
            this.duration = _data["duration"] ? Duration.fromJS(_data["duration"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DurationBuildingType {
        data = typeof data === 'object' ? data : {};
        let result = new DurationBuildingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }

    clone(): DurationBuildingType {
        const json = this.toJSON();
        let result = new DurationBuildingType();
        result.init(json);
        return result;
    }
}

export interface IDurationBuildingType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    durationId: number;
    duration: Duration;
    type: BuildingType;
}

export class DurationBuildingTypeShowDto implements IDurationBuildingTypeShowDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    durationId: number;
    type: BuildingType;

    constructor(data?: IDurationBuildingTypeShowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.durationId = _data["durationId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DurationBuildingTypeShowDto {
        data = typeof data === 'object' ? data : {};
        let result = new DurationBuildingTypeShowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["durationId"] = this.durationId;
        data["type"] = this.type;
        return data;
    }

    clone(): DurationBuildingTypeShowDto {
        const json = this.toJSON();
        let result = new DurationBuildingTypeShowDto();
        result.init(json);
        return result;
    }
}

export interface IDurationBuildingTypeShowDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    durationId: number;
    type: BuildingType;
}

export class DurationDto implements IDurationDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    period: number;
    amount: number;
    isPublish: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    buildingTypes: BuildingType[] | undefined;
    durationBuildingTypes: DurationBuildingTypeShowDto[] | undefined;

    constructor(data?: IDurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.period = _data["period"];
            this.amount = _data["amount"];
            this.isPublish = _data["isPublish"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
            if (Array.isArray(_data["buildingTypes"])) {
                this.buildingTypes = [] as any;
                for (let item of _data["buildingTypes"])
                    this.buildingTypes.push(item);
            }
            if (Array.isArray(_data["durationBuildingTypes"])) {
                this.durationBuildingTypes = [] as any;
                for (let item of _data["durationBuildingTypes"])
                    this.durationBuildingTypes.push(DurationBuildingTypeShowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new DurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["period"] = this.period;
        data["amount"] = this.amount;
        data["isPublish"] = this.isPublish;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        if (Array.isArray(this.buildingTypes)) {
            data["buildingTypes"] = [];
            for (let item of this.buildingTypes)
                data["buildingTypes"].push(item);
        }
        if (Array.isArray(this.durationBuildingTypes)) {
            data["durationBuildingTypes"] = [];
            for (let item of this.durationBuildingTypes)
                data["durationBuildingTypes"].push(item.toJSON());
        }
        return data;
    }

    clone(): DurationDto {
        const json = this.toJSON();
        let result = new DurationDto();
        result.init(json);
        return result;
    }
}

export interface IDurationDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    period: number;
    amount: number;
    isPublish: boolean;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    buildingTypes: BuildingType[] | undefined;
    durationBuildingTypes: DurationBuildingTypeShowDto[] | undefined;
}

export class DurationDtoDataTableOutputDto implements IDurationDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DurationDto[] | undefined;

    constructor(data?: IDurationDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(DurationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DurationDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DurationDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DurationDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new DurationDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IDurationDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: DurationDto[] | undefined;
}

export class DurationDtoPagedResultDto implements IDurationDtoPagedResultDto {
    items: DurationDto[] | undefined;
    totalCount: number;

    constructor(data?: IDurationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DurationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DurationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DurationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DurationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DurationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDurationDtoPagedResultDto {
    items: DurationDto[] | undefined;
    totalCount: number;
}

export enum ExpiredStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FacilityDtoApi implements IFacilityDtoApi {
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    isChecked: string | undefined;

    constructor(data?: IFacilityDtoApi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.avatar = _data["avatar"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): FacilityDtoApi {
        data = typeof data === 'object' ? data : {};
        let result = new FacilityDtoApi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["avatar"] = this.avatar;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): FacilityDtoApi {
        const json = this.toJSON();
        let result = new FacilityDtoApi();
        result.init(json);
        return result;
    }
}

export interface IFacilityDtoApi {
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    isChecked: string | undefined;
}

export class FacilityDtoForEdit implements IFacilityDtoForEdit {
    id: number;
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    isSelected: boolean;

    constructor(data?: IFacilityDtoForEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.avatar = _data["avatar"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): FacilityDtoForEdit {
        data = typeof data === 'object' ? data : {};
        let result = new FacilityDtoForEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["avatar"] = this.avatar;
        data["isSelected"] = this.isSelected;
        return data;
    }

    clone(): FacilityDtoForEdit {
        const json = this.toJSON();
        let result = new FacilityDtoForEdit();
        result.init(json);
        return result;
    }
}

export interface IFacilityDtoForEdit {
    id: number;
    name: string | undefined;
    description: string | undefined;
    avatar: string | undefined;
    isSelected: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class ForgetPasswordDto implements IForgetPasswordDto {
    userNameOrEmailAddress: string | undefined;

    constructor(data?: IForgetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
        }
    }

    static fromJS(data: any): ForgetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        return data;
    }

    clone(): ForgetPasswordDto {
        const json = this.toJSON();
        let result = new ForgetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IForgetPasswordDto {
    userNameOrEmailAddress: string | undefined;
}

export class GetAdvertisementInput implements IGetAdvertisementInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    isApprove: ApprovalStatus;
    isEdited: boolean | undefined;

    constructor(data?: IGetAdvertisementInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
            this.isApprove = _data["isApprove"];
            this.isEdited = _data["isEdited"];
        }
    }

    static fromJS(data: any): GetAdvertisementInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdvertisementInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        data["isApprove"] = this.isApprove;
        data["isEdited"] = this.isEdited;
        return data;
    }

    clone(): GetAdvertisementInput {
        const json = this.toJSON();
        let result = new GetAdvertisementInput();
        result.init(json);
        return result;
    }
}

export interface IGetAdvertisementInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    isApprove: ApprovalStatus;
    isEdited: boolean | undefined;
}

export class GetAdvertisementOutput implements IGetAdvertisementOutput {
    advertisements: AdvertisementDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetAdvertisementOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(AdvertisementDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetAdvertisementOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdvertisementOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetAdvertisementOutput {
        const json = this.toJSON();
        let result = new GetAdvertisementOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAdvertisementOutput {
    advertisements: AdvertisementDto[] | undefined;
    error: string | undefined;
}

export class GetAdvertisementSearchInput implements IGetAdvertisementSearchInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    streetOrCompund: string | undefined;
    rooms: number | undefined;
    area: string | undefined;
    areaFrom: number | undefined;
    areaTo: number | undefined;
    decoration: DecorationStatus;
    furnished: boolean | undefined;
    parking: boolean | undefined;
    agreementStatus: AgreementStatus;
    priceFrom: number | undefined;
    priceTo: number | undefined;
    isEdited: boolean | undefined;
    companyId: number | undefined;

    constructor(data?: IGetAdvertisementSearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.governorateId = _data["governorateId"];
            this.streetOrCompund = _data["streetOrCompund"];
            this.rooms = _data["rooms"];
            this.area = _data["area"];
            this.areaFrom = _data["areaFrom"];
            this.areaTo = _data["areaTo"];
            this.decoration = _data["decoration"];
            this.furnished = _data["furnished"];
            this.parking = _data["parking"];
            this.agreementStatus = _data["agreementStatus"];
            this.priceFrom = _data["priceFrom"];
            this.priceTo = _data["priceTo"];
            this.isEdited = _data["isEdited"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): GetAdvertisementSearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdvertisementSearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["governorateId"] = this.governorateId;
        data["streetOrCompund"] = this.streetOrCompund;
        data["rooms"] = this.rooms;
        data["area"] = this.area;
        data["areaFrom"] = this.areaFrom;
        data["areaTo"] = this.areaTo;
        data["decoration"] = this.decoration;
        data["furnished"] = this.furnished;
        data["parking"] = this.parking;
        data["agreementStatus"] = this.agreementStatus;
        data["priceFrom"] = this.priceFrom;
        data["priceTo"] = this.priceTo;
        data["isEdited"] = this.isEdited;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): GetAdvertisementSearchInput {
        const json = this.toJSON();
        let result = new GetAdvertisementSearchInput();
        result.init(json);
        return result;
    }
}

export interface IGetAdvertisementSearchInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    type: BuildingType;
    cityId: number | undefined;
    governorateId: number | undefined;
    streetOrCompund: string | undefined;
    rooms: number | undefined;
    area: string | undefined;
    areaFrom: number | undefined;
    areaTo: number | undefined;
    decoration: DecorationStatus;
    furnished: boolean | undefined;
    parking: boolean | undefined;
    agreementStatus: AgreementStatus;
    priceFrom: number | undefined;
    priceTo: number | undefined;
    isEdited: boolean | undefined;
    companyId: number | undefined;
}

export class GetAllCitiesInput implements IGetAllCitiesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
    governorateId: number | undefined;

    constructor(data?: IGetAllCitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
            this.governorateId = _data["governorateId"];
        }
    }

    static fromJS(data: any): GetAllCitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        data["governorateId"] = this.governorateId;
        return data;
    }

    clone(): GetAllCitiesInput {
        const json = this.toJSON();
        let result = new GetAllCitiesInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllCitiesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
    governorateId: number | undefined;
}

export class GetAllCitiesOutput implements IGetAllCitiesOutput {
    cities: ApiCityDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllCitiesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities.push(ApiCityDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllCitiesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCitiesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllCitiesOutput {
        const json = this.toJSON();
        let result = new GetAllCitiesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllCitiesOutput {
    cities: ApiCityDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllCountriesInput implements IGetAllCountriesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllCountriesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllCountriesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCountriesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllCountriesInput {
        const json = this.toJSON();
        let result = new GetAllCountriesInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllCountriesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllCountriesOutput implements IGetAllCountriesOutput {
    countries: ApiCountryDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllCountriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries.push(ApiCountryDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllCountriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCountriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllCountriesOutput {
        const json = this.toJSON();
        let result = new GetAllCountriesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllCountriesOutput {
    countries: ApiCountryDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllDefinitionsInput implements IGetAllDefinitionsInput {
    keyword: string | undefined;
    type: number;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllDefinitionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.type = _data["type"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllDefinitionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDefinitionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["type"] = this.type;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllDefinitionsInput {
        const json = this.toJSON();
        let result = new GetAllDefinitionsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllDefinitionsInput {
    keyword: string | undefined;
    type: number;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllDefinitionsOutput implements IGetAllDefinitionsOutput {
    definitions: ApiDefinitionDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllDefinitionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definitions"])) {
                this.definitions = [] as any;
                for (let item of _data["definitions"])
                    this.definitions.push(ApiDefinitionDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllDefinitionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDefinitionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definitions)) {
            data["definitions"] = [];
            for (let item of this.definitions)
                data["definitions"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllDefinitionsOutput {
        const json = this.toJSON();
        let result = new GetAllDefinitionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllDefinitionsOutput {
    definitions: ApiDefinitionDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllDurationsInput implements IGetAllDurationsInput {
    type: BuildingType;
    isPublish: boolean | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllDurationsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.isPublish = _data["isPublish"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllDurationsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDurationsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["isPublish"] = this.isPublish;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllDurationsInput {
        const json = this.toJSON();
        let result = new GetAllDurationsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllDurationsInput {
    type: BuildingType;
    isPublish: boolean | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllDurationsOutput implements IGetAllDurationsOutput {
    durations: ApiDurationDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllDurationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["durations"])) {
                this.durations = [] as any;
                for (let item of _data["durations"])
                    this.durations.push(ApiDurationDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllDurationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDurationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.durations)) {
            data["durations"] = [];
            for (let item of this.durations)
                data["durations"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllDurationsOutput {
        const json = this.toJSON();
        let result = new GetAllDurationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllDurationsOutput {
    durations: ApiDurationDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllGovernoratesInput implements IGetAllGovernoratesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllGovernoratesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllGovernoratesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllGovernoratesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllGovernoratesInput {
        const json = this.toJSON();
        let result = new GetAllGovernoratesInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllGovernoratesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllGovernoratesOutput implements IGetAllGovernoratesOutput {
    governorates: ApiGovernorateDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllGovernoratesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["governorates"])) {
                this.governorates = [] as any;
                for (let item of _data["governorates"])
                    this.governorates.push(ApiGovernorateDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllGovernoratesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllGovernoratesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.governorates)) {
            data["governorates"] = [];
            for (let item of this.governorates)
                data["governorates"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllGovernoratesOutput {
        const json = this.toJSON();
        let result = new GetAllGovernoratesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllGovernoratesOutput {
    governorates: ApiGovernorateDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllPackagesInput implements IGetAllPackagesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllPackagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllPackagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPackagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllPackagesInput {
        const json = this.toJSON();
        let result = new GetAllPackagesInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllPackagesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllPackagesOutput implements IGetAllPackagesOutput {
    packages: ApiPackageDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllPackagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages.push(ApiPackageDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllPackagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPackagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllPackagesOutput {
        const json = this.toJSON();
        let result = new GetAllPackagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllPackagesOutput {
    packages: ApiPackageDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllProjectsOutput implements IGetAllProjectsOutput {
    projects: ApiProjectDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllProjectsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects.push(ApiProjectDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllProjectsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllProjectsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllProjectsOutput {
        const json = this.toJSON();
        let result = new GetAllProjectsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllProjectsOutput {
    projects: ApiProjectDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllRatesInput implements IGetAllRatesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllRatesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllRatesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllRatesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllRatesInput {
        const json = this.toJSON();
        let result = new GetAllRatesInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllRatesInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllRatesOutput implements IGetAllRatesOutput {
    rates: ApiRateDto[] | undefined;
    count: number | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllRatesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rates"])) {
                this.rates = [] as any;
                for (let item of _data["rates"])
                    this.rates.push(ApiRateDto.fromJS(item));
            }
            this.count = _data["count"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllRatesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllRatesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rates)) {
            data["rates"] = [];
            for (let item of this.rates)
                data["rates"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllRatesOutput {
        const json = this.toJSON();
        let result = new GetAllRatesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllRatesOutput {
    rates: ApiRateDto[] | undefined;
    count: number | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllSocialContactsInput implements IGetAllSocialContactsInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllSocialContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllSocialContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSocialContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllSocialContactsInput {
        const json = this.toJSON();
        let result = new GetAllSocialContactsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSocialContactsInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllSocialContactsOutput implements IGetAllSocialContactsOutput {
    socialContacts: ApiSocialContactDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllSocialContactsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["socialContacts"])) {
                this.socialContacts = [] as any;
                for (let item of _data["socialContacts"])
                    this.socialContacts.push(ApiSocialContactDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllSocialContactsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSocialContactsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.socialContacts)) {
            data["socialContacts"] = [];
            for (let item of this.socialContacts)
                data["socialContacts"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllSocialContactsOutput {
        const json = this.toJSON();
        let result = new GetAllSocialContactsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSocialContactsOutput {
    socialContacts: ApiSocialContactDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetAllSponsorsInput implements IGetAllSponsorsInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;

    constructor(data?: IGetAllSponsorsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.start = _data["start"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): GetAllSponsorsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSponsorsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["start"] = this.start;
        data["length"] = this.length;
        return data;
    }

    clone(): GetAllSponsorsInput {
        const json = this.toJSON();
        let result = new GetAllSponsorsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSponsorsInput {
    keyword: string | undefined;
    start: number | undefined;
    length: number | undefined;
}

export class GetAllSponsorsOutput implements IGetAllSponsorsOutput {
    sponsors: ApiSponsorDto[] | undefined;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetAllSponsorsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sponsors"])) {
                this.sponsors = [] as any;
                for (let item of _data["sponsors"])
                    this.sponsors.push(ApiSponsorDto.fromJS(item));
            }
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetAllSponsorsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSponsorsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sponsors)) {
            data["sponsors"] = [];
            for (let item of this.sponsors)
                data["sponsors"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetAllSponsorsOutput {
        const json = this.toJSON();
        let result = new GetAllSponsorsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSponsorsOutput {
    sponsors: ApiSponsorDto[] | undefined;
    error: string | undefined;
    success: boolean;
}

export class GetBrokerPersonInput implements IGetBrokerPersonInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetBrokerPersonInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetBrokerPersonInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrokerPersonInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetBrokerPersonInput {
        const json = this.toJSON();
        let result = new GetBrokerPersonInput();
        result.init(json);
        return result;
    }
}

export interface IGetBrokerPersonInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetBrokerPersonOutput implements IGetBrokerPersonOutput {
    brokerPersons: BrokerPersonDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetBrokerPersonOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["brokerPersons"])) {
                this.brokerPersons = [] as any;
                for (let item of _data["brokerPersons"])
                    this.brokerPersons.push(BrokerPersonDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetBrokerPersonOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrokerPersonOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.brokerPersons)) {
            data["brokerPersons"] = [];
            for (let item of this.brokerPersons)
                data["brokerPersons"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetBrokerPersonOutput {
        const json = this.toJSON();
        let result = new GetBrokerPersonOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBrokerPersonOutput {
    brokerPersons: BrokerPersonDto[] | undefined;
    error: string | undefined;
}

export class GetCityInput implements IGetCityInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetCityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetCityInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetCityInput {
        const json = this.toJSON();
        let result = new GetCityInput();
        result.init(json);
        return result;
    }
}

export interface IGetCityInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetCompanyInput implements IGetCompanyInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetCompanyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetCompanyInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetCompanyInput {
        const json = this.toJSON();
        let result = new GetCompanyInput();
        result.init(json);
        return result;
    }
}

export interface IGetCompanyInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetCompanyOutput implements IGetCompanyOutput {
    companys: CompanyDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetCompanyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companys"])) {
                this.companys = [] as any;
                for (let item of _data["companys"])
                    this.companys.push(CompanyDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetCompanyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companys)) {
            data["companys"] = [];
            for (let item of this.companys)
                data["companys"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetCompanyOutput {
        const json = this.toJSON();
        let result = new GetCompanyOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCompanyOutput {
    companys: CompanyDto[] | undefined;
    error: string | undefined;
}

export class GetContactUsInput implements IGetContactUsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IGetContactUsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): GetContactUsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactUsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): GetContactUsInput {
        const json = this.toJSON();
        let result = new GetContactUsInput();
        result.init(json);
        return result;
    }
}

export interface IGetContactUsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    emailAddress: string | undefined;
}

export class GetCountriesInput implements IGetCountriesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetCountriesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetCountriesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountriesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetCountriesInput {
        const json = this.toJSON();
        let result = new GetCountriesInput();
        result.init(json);
        return result;
    }
}

export interface IGetCountriesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetCountriesOutput implements IGetCountriesOutput {
    countries: CountryDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetCountriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries.push(CountryDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetCountriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetCountriesOutput {
        const json = this.toJSON();
        let result = new GetCountriesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCountriesOutput {
    countries: CountryDto[] | undefined;
    error: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    brokerPerson: BrokerPersonLoginInfoDto;
    seeker: SeekerLoginInfoDto;
    owner: OwnerLoginInfoDto;
    company: CompanyLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.brokerPerson = _data["brokerPerson"] ? BrokerPersonLoginInfoDto.fromJS(_data["brokerPerson"]) : <any>undefined;
            this.seeker = _data["seeker"] ? SeekerLoginInfoDto.fromJS(_data["seeker"]) : <any>undefined;
            this.owner = _data["owner"] ? OwnerLoginInfoDto.fromJS(_data["owner"]) : <any>undefined;
            this.company = _data["company"] ? CompanyLoginInfoDto.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["brokerPerson"] = this.brokerPerson ? this.brokerPerson.toJSON() : <any>undefined;
        data["seeker"] = this.seeker ? this.seeker.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    brokerPerson: BrokerPersonLoginInfoDto;
    seeker: SeekerLoginInfoDto;
    owner: OwnerLoginInfoDto;
    company: CompanyLoginInfoDto;
}

export class GetDefinitionsInput implements IGetDefinitionsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    enumCategory: DefinitionTypes;

    constructor(data?: IGetDefinitionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
            this.enumCategory = _data["enumCategory"];
        }
    }

    static fromJS(data: any): GetDefinitionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefinitionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        data["enumCategory"] = this.enumCategory;
        return data;
    }

    clone(): GetDefinitionsInput {
        const json = this.toJSON();
        let result = new GetDefinitionsInput();
        result.init(json);
        return result;
    }
}

export interface IGetDefinitionsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    enumCategory: DefinitionTypes;
}

export class GetDefinitionsOutput implements IGetDefinitionsOutput {
    definitions: DefinitionDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetDefinitionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definitions"])) {
                this.definitions = [] as any;
                for (let item of _data["definitions"])
                    this.definitions.push(DefinitionDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetDefinitionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefinitionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definitions)) {
            data["definitions"] = [];
            for (let item of this.definitions)
                data["definitions"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetDefinitionsOutput {
        const json = this.toJSON();
        let result = new GetDefinitionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefinitionsOutput {
    definitions: DefinitionDto[] | undefined;
    error: string | undefined;
}

export class GetDiscontCodeInput implements IGetDiscontCodeInput {
    keyword: string | undefined;

    constructor(data?: IGetDiscontCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): GetDiscontCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDiscontCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        return data;
    }

    clone(): GetDiscontCodeInput {
        const json = this.toJSON();
        let result = new GetDiscontCodeInput();
        result.init(json);
        return result;
    }
}

export interface IGetDiscontCodeInput {
    keyword: string | undefined;
}

export class GetDiscontCodeOutput implements IGetDiscontCodeOutput {
    discount: ApiDiscountDto;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetDiscontCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discount = _data["discount"] ? ApiDiscountDto.fromJS(_data["discount"]) : <any>undefined;
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetDiscontCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDiscontCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetDiscontCodeOutput {
        const json = this.toJSON();
        let result = new GetDiscontCodeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDiscontCodeOutput {
    discount: ApiDiscountDto;
    error: string | undefined;
    success: boolean;
}

export class GetDiscountCodesInput implements IGetDiscountCodesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;

    constructor(data?: IGetDiscountCodesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
        }
    }

    static fromJS(data: any): GetDiscountCodesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDiscountCodesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        return data;
    }

    clone(): GetDiscountCodesInput {
        const json = this.toJSON();
        let result = new GetDiscountCodesInput();
        result.init(json);
        return result;
    }
}

export interface IGetDiscountCodesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
}

export class GetDurationInput implements IGetDurationInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;

    constructor(data?: IGetDurationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
        }
    }

    static fromJS(data: any): GetDurationInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDurationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        return data;
    }

    clone(): GetDurationInput {
        const json = this.toJSON();
        let result = new GetDurationInput();
        result.init(json);
        return result;
    }
}

export interface IGetDurationInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
}

export class GetFavoriteOutput implements IGetFavoriteOutput {
    adFavorites: AdFavoriteDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetFavoriteOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adFavorites"])) {
                this.adFavorites = [] as any;
                for (let item of _data["adFavorites"])
                    this.adFavorites.push(AdFavoriteDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetFavoriteOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFavoriteOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adFavorites)) {
            data["adFavorites"] = [];
            for (let item of this.adFavorites)
                data["adFavorites"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetFavoriteOutput {
        const json = this.toJSON();
        let result = new GetFavoriteOutput();
        result.init(json);
        return result;
    }
}

export interface IGetFavoriteOutput {
    adFavorites: AdFavoriteDto[] | undefined;
    error: string | undefined;
}

export class GetGovernoratesInput implements IGetGovernoratesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetGovernoratesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetGovernoratesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGovernoratesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetGovernoratesInput {
        const json = this.toJSON();
        let result = new GetGovernoratesInput();
        result.init(json);
        return result;
    }
}

export interface IGetGovernoratesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetGovernoratesOutput implements IGetGovernoratesOutput {
    governorates: GovernorateDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetGovernoratesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["governorates"])) {
                this.governorates = [] as any;
                for (let item of _data["governorates"])
                    this.governorates.push(GovernorateDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetGovernoratesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGovernoratesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.governorates)) {
            data["governorates"] = [];
            for (let item of this.governorates)
                data["governorates"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetGovernoratesOutput {
        const json = this.toJSON();
        let result = new GetGovernoratesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGovernoratesOutput {
    governorates: GovernorateDto[] | undefined;
    error: string | undefined;
}

export class GetIsEmailExist implements IGetIsEmailExist {
    exist: boolean;
    error: string | undefined;
    success: boolean;

    constructor(data?: IGetIsEmailExist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exist = _data["exist"];
            this.error = _data["error"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): GetIsEmailExist {
        data = typeof data === 'object' ? data : {};
        let result = new GetIsEmailExist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exist"] = this.exist;
        data["error"] = this.error;
        data["success"] = this.success;
        return data;
    }

    clone(): GetIsEmailExist {
        const json = this.toJSON();
        let result = new GetIsEmailExist();
        result.init(json);
        return result;
    }
}

export interface IGetIsEmailExist {
    exist: boolean;
    error: string | undefined;
    success: boolean;
}

export class GetNotificationListOutput implements IGetNotificationListOutput {
    notifications: NotificationDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetNotificationListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications.push(NotificationDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetNotificationListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetNotificationListOutput {
        const json = this.toJSON();
        let result = new GetNotificationListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationListOutput {
    notifications: NotificationDto[] | undefined;
    error: string | undefined;
}

export class GetOwnerInput implements IGetOwnerInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetOwnerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetOwnerInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetOwnerInput {
        const json = this.toJSON();
        let result = new GetOwnerInput();
        result.init(json);
        return result;
    }
}

export interface IGetOwnerInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetOwnerOutput implements IGetOwnerOutput {
    owners: OwnerDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetOwnerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["owners"])) {
                this.owners = [] as any;
                for (let item of _data["owners"])
                    this.owners.push(OwnerDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetOwnerOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.owners)) {
            data["owners"] = [];
            for (let item of this.owners)
                data["owners"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetOwnerOutput {
        const json = this.toJSON();
        let result = new GetOwnerOutput();
        result.init(json);
        return result;
    }
}

export interface IGetOwnerOutput {
    owners: OwnerDto[] | undefined;
    error: string | undefined;
}

export class GetPackagesInput implements IGetPackagesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetPackagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetPackagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetPackagesInput {
        const json = this.toJSON();
        let result = new GetPackagesInput();
        result.init(json);
        return result;
    }
}

export interface IGetPackagesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetPackagesOutput implements IGetPackagesOutput {
    packages: PackageDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetPackagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages.push(PackageDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetPackagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetPackagesOutput {
        const json = this.toJSON();
        let result = new GetPackagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPackagesOutput {
    packages: PackageDto[] | undefined;
    error: string | undefined;
}

export class GetProjectInput implements IGetProjectInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    isApprove: ApprovalStatus;
    newer: boolean | undefined;

    constructor(data?: IGetProjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
            this.isApprove = _data["isApprove"];
            this.newer = _data["newer"];
        }
    }

    static fromJS(data: any): GetProjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        data["isApprove"] = this.isApprove;
        data["newer"] = this.newer;
        return data;
    }

    clone(): GetProjectInput {
        const json = this.toJSON();
        let result = new GetProjectInput();
        result.init(json);
        return result;
    }
}

export interface IGetProjectInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    isApprove: ApprovalStatus;
    newer: boolean | undefined;
}

export class GetProjectOutput implements IGetProjectOutput {
    projects: ProjectDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetProjectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects.push(ProjectDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetProjectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetProjectOutput {
        const json = this.toJSON();
        let result = new GetProjectOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProjectOutput {
    projects: ProjectDto[] | undefined;
    error: string | undefined;
}

export class GetRatesInput implements IGetRatesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetRatesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetRatesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRatesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetRatesInput {
        const json = this.toJSON();
        let result = new GetRatesInput();
        result.init(json);
        return result;
    }
}

export interface IGetRatesInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetRatesOutput implements IGetRatesOutput {
    rates: RateDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetRatesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rates"])) {
                this.rates = [] as any;
                for (let item of _data["rates"])
                    this.rates.push(RateDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetRatesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRatesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rates)) {
            data["rates"] = [];
            for (let item of this.rates)
                data["rates"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetRatesOutput {
        const json = this.toJSON();
        let result = new GetRatesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRatesOutput {
    rates: RateDto[] | undefined;
    error: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetSeekerInput implements IGetSeekerInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetSeekerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetSeekerInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeekerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetSeekerInput {
        const json = this.toJSON();
        let result = new GetSeekerInput();
        result.init(json);
        return result;
    }
}

export interface IGetSeekerInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetSeekerOutput implements IGetSeekerOutput {
    seekers: SeekerDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetSeekerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["seekers"])) {
                this.seekers = [] as any;
                for (let item of _data["seekers"])
                    this.seekers.push(SeekerDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetSeekerOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeekerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.seekers)) {
            data["seekers"] = [];
            for (let item of this.seekers)
                data["seekers"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetSeekerOutput {
        const json = this.toJSON();
        let result = new GetSeekerOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSeekerOutput {
    seekers: SeekerDto[] | undefined;
    error: string | undefined;
}

export class GetSettingDefinitionsOutput implements IGetSettingDefinitionsOutput {
    items: SettingDefinition[] | undefined;
    values: ISettingValue[] | undefined;
    explicitValues: ISettingValue[] | undefined;

    constructor(data?: IGetSettingDefinitionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SettingDefinition.fromJS(item));
            }
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values.push(ISettingValue.fromJS(item));
            }
            if (Array.isArray(_data["explicitValues"])) {
                this.explicitValues = [] as any;
                for (let item of _data["explicitValues"])
                    this.explicitValues.push(ISettingValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSettingDefinitionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingDefinitionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.explicitValues)) {
            data["explicitValues"] = [];
            for (let item of this.explicitValues)
                data["explicitValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetSettingDefinitionsOutput {
        const json = this.toJSON();
        let result = new GetSettingDefinitionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSettingDefinitionsOutput {
    items: SettingDefinition[] | undefined;
    values: ISettingValue[] | undefined;
    explicitValues: ISettingValue[] | undefined;
}

export class GetSocialContactsInput implements IGetSocialContactsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetSocialContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetSocialContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSocialContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetSocialContactsInput {
        const json = this.toJSON();
        let result = new GetSocialContactsInput();
        result.init(json);
        return result;
    }
}

export interface IGetSocialContactsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetSocialContactsOutput implements IGetSocialContactsOutput {
    socialContacts: SocialContactDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetSocialContactsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["socialContacts"])) {
                this.socialContacts = [] as any;
                for (let item of _data["socialContacts"])
                    this.socialContacts.push(SocialContactDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetSocialContactsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSocialContactsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.socialContacts)) {
            data["socialContacts"] = [];
            for (let item of this.socialContacts)
                data["socialContacts"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetSocialContactsOutput {
        const json = this.toJSON();
        let result = new GetSocialContactsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSocialContactsOutput {
    socialContacts: SocialContactDto[] | undefined;
    error: string | undefined;
}

export class GetUserDevicesOutput implements IGetUserDevicesOutput {
    userDevices: UserDeviceDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetUserDevicesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userDevices"])) {
                this.userDevices = [] as any;
                for (let item of _data["userDevices"])
                    this.userDevices.push(UserDeviceDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetUserDevicesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDevicesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userDevices)) {
            data["userDevices"] = [];
            for (let item of this.userDevices)
                data["userDevices"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetUserDevicesOutput {
        const json = this.toJSON();
        let result = new GetUserDevicesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserDevicesOutput {
    userDevices: UserDeviceDto[] | undefined;
    error: string | undefined;
}

export class GetUserWithPermissionsOutput implements IGetUserWithPermissionsOutput {
    user: UserDto;
    grantedPermissions: PermissionCustomDto[] | undefined;
    allPermissions: PermissionCustomDto[] | undefined;

    constructor(data?: IGetUserWithPermissionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(PermissionCustomDto.fromJS(item));
            }
            if (Array.isArray(_data["allPermissions"])) {
                this.allPermissions = [] as any;
                for (let item of _data["allPermissions"])
                    this.allPermissions.push(PermissionCustomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserWithPermissionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserWithPermissionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.allPermissions)) {
            data["allPermissions"] = [];
            for (let item of this.allPermissions)
                data["allPermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetUserWithPermissionsOutput {
        const json = this.toJSON();
        let result = new GetUserWithPermissionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserWithPermissionsOutput {
    user: UserDto;
    grantedPermissions: PermissionCustomDto[] | undefined;
    allPermissions: PermissionCustomDto[] | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        return data;
    }

    clone(): GetUsersInput {
        const json = this.toJSON();
        let result = new GetUsersInput();
        result.init(json);
        return result;
    }
}

export interface IGetUsersInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
}

export class GetViewOutput implements IGetViewOutput {
    adViews: AdViewDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetViewOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adViews"])) {
                this.adViews = [] as any;
                for (let item of _data["adViews"])
                    this.adViews.push(AdViewDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetViewOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetViewOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adViews)) {
            data["adViews"] = [];
            for (let item of this.adViews)
                data["adViews"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetViewOutput {
        const json = this.toJSON();
        let result = new GetViewOutput();
        result.init(json);
        return result;
    }
}

export interface IGetViewOutput {
    adViews: AdViewDto[] | undefined;
    error: string | undefined;
}

export class GetWalletsInput implements IGetWalletsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    companyId: number | undefined;
    enumTransaction: TransactionType;

    constructor(data?: IGetWalletsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            this.start = _data["start"];
            this.length = _data["length"];
            this.draw = _data["draw"];
            this.isDeleted = _data["isDeleted"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTimeFrom = _data["creationTimeFrom"] ? moment(_data["creationTimeFrom"].toString()) : <any>undefined;
            this.creationTimeTo = _data["creationTimeTo"] ? moment(_data["creationTimeTo"].toString()) : <any>undefined;
            this.modifierUserName = _data["modifierUserName"];
            this.lastModificationTimeFrom = _data["lastModificationTimeFrom"] ? moment(_data["lastModificationTimeFrom"].toString()) : <any>undefined;
            this.lastModificationTimeTo = _data["lastModificationTimeTo"] ? moment(_data["lastModificationTimeTo"].toString()) : <any>undefined;
            this.deleterUserName = _data["deleterUserName"];
            this.deletionTimeFrom = _data["deletionTimeFrom"] ? moment(_data["deletionTimeFrom"].toString()) : <any>undefined;
            this.deletionTimeTo = _data["deletionTimeTo"] ? moment(_data["deletionTimeTo"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.action = _data["action"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.lang = _data["lang"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.enumTransaction = _data["enumTransaction"];
        }
    }

    static fromJS(data: any): GetWalletsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWalletsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["length"] = this.length;
        data["draw"] = this.draw;
        data["isDeleted"] = this.isDeleted;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTimeFrom"] = this.creationTimeFrom ? this.creationTimeFrom.toISOString() : <any>undefined;
        data["creationTimeTo"] = this.creationTimeTo ? this.creationTimeTo.toISOString() : <any>undefined;
        data["modifierUserName"] = this.modifierUserName;
        data["lastModificationTimeFrom"] = this.lastModificationTimeFrom ? this.lastModificationTimeFrom.toISOString() : <any>undefined;
        data["lastModificationTimeTo"] = this.lastModificationTimeTo ? this.lastModificationTimeTo.toISOString() : <any>undefined;
        data["deleterUserName"] = this.deleterUserName;
        data["deletionTimeFrom"] = this.deletionTimeFrom ? this.deletionTimeFrom.toISOString() : <any>undefined;
        data["deletionTimeTo"] = this.deletionTimeTo ? this.deletionTimeTo.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["action"] = this.action;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["lang"] = this.lang;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["enumTransaction"] = this.enumTransaction;
        return data;
    }

    clone(): GetWalletsInput {
        const json = this.toJSON();
        let result = new GetWalletsInput();
        result.init(json);
        return result;
    }
}

export interface IGetWalletsInput {
    columns: Column[] | undefined;
    order: Order[] | undefined;
    start: number;
    length: number;
    draw: number;
    isDeleted: boolean | undefined;
    creatorUserName: string | undefined;
    creationTimeFrom: moment.Moment | undefined;
    creationTimeTo: moment.Moment | undefined;
    modifierUserName: string | undefined;
    lastModificationTimeFrom: moment.Moment | undefined;
    lastModificationTimeTo: moment.Moment | undefined;
    deleterUserName: string | undefined;
    deletionTimeFrom: moment.Moment | undefined;
    deletionTimeTo: moment.Moment | undefined;
    actionType: string | undefined;
    action: string | undefined;
    ids: string[] | undefined;
    lang: string | undefined;
    name: string | undefined;
    companyId: number | undefined;
    enumTransaction: TransactionType;
}

export class GetWalletsOutput implements IGetWalletsOutput {
    wallets: WalletDto[] | undefined;
    error: string | undefined;

    constructor(data?: IGetWalletsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["wallets"])) {
                this.wallets = [] as any;
                for (let item of _data["wallets"])
                    this.wallets.push(WalletDto.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): GetWalletsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWalletsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.wallets)) {
            data["wallets"] = [];
            for (let item of this.wallets)
                data["wallets"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }

    clone(): GetWalletsOutput {
        const json = this.toJSON();
        let result = new GetWalletsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWalletsOutput {
    wallets: WalletDto[] | undefined;
    error: string | undefined;
}

export class Governorate implements IGovernorate {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    countryId: number;
    country: Country;

    constructor(data?: IGovernorate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Governorate {
        data = typeof data === 'object' ? data : {};
        let result = new Governorate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }

    clone(): Governorate {
        const json = this.toJSON();
        let result = new Governorate();
        result.init(json);
        return result;
    }
}

export interface IGovernorate {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    countryId: number;
    country: Country;
}

export class GovernorateDto implements IGovernorateDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    countryId: number;
    country: CountryDto;
    nameAr: string | undefined;
    nameEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IGovernorateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GovernorateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): GovernorateDto {
        const json = this.toJSON();
        let result = new GovernorateDto();
        result.init(json);
        return result;
    }
}

export interface IGovernorateDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    countryId: number;
    country: CountryDto;
    nameAr: string | undefined;
    nameEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class GovernorateDtoDataTableOutputDto implements IGovernorateDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: GovernorateDto[] | undefined;

    constructor(data?: IGovernorateDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(GovernorateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GovernorateDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GovernorateDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): GovernorateDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new GovernorateDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IGovernorateDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: GovernorateDto[] | undefined;
}

export class ILocalizableString implements IILocalizableString {

    constructor(data?: IILocalizableString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ILocalizableString {
        data = typeof data === 'object' ? data : {};
        let result = new ILocalizableString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): ILocalizableString {
        const json = this.toJSON();
        let result = new ILocalizableString();
        result.init(json);
        return result;
    }
}

export interface IILocalizableString {
}

export class ISettingClientVisibilityProvider implements IISettingClientVisibilityProvider {

    constructor(data?: IISettingClientVisibilityProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ISettingClientVisibilityProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ISettingClientVisibilityProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): ISettingClientVisibilityProvider {
        const json = this.toJSON();
        let result = new ISettingClientVisibilityProvider();
        result.init(json);
        return result;
    }
}

export interface IISettingClientVisibilityProvider {
}

export class ISettingValue implements IISettingValue {
    readonly name: string | undefined;
    readonly value: string | undefined;

    constructor(data?: IISettingValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): ISettingValue {
        data = typeof data === 'object' ? data : {};
        let result = new ISettingValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): ISettingValue {
        const json = this.toJSON();
        let result = new ISettingValue();
        result.init(json);
        return result;
    }
}

export interface IISettingValue {
    name: string | undefined;
    value: string | undefined;
}

export class Image implements IImage {
    tag: any | undefined;
    physicalDimension: SizeF;
    size: Size;
    readonly width: number;
    readonly height: number;
    readonly horizontalResolution: number;
    readonly verticalResolution: number;
    readonly flags: number;
    rawFormat: ImageFormat;
    pixelFormat: PixelFormat;
    readonly propertyIdList: number[] | undefined;
    readonly propertyItems: PropertyItem[] | undefined;
    palette: ColorPalette;
    readonly frameDimensionsList: string[] | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tag = _data["tag"];
            this.physicalDimension = _data["physicalDimension"] ? SizeF.fromJS(_data["physicalDimension"]) : <any>undefined;
            this.size = _data["size"] ? Size.fromJS(_data["size"]) : <any>undefined;
            (<any>this).width = _data["width"];
            (<any>this).height = _data["height"];
            (<any>this).horizontalResolution = _data["horizontalResolution"];
            (<any>this).verticalResolution = _data["verticalResolution"];
            (<any>this).flags = _data["flags"];
            this.rawFormat = _data["rawFormat"] ? ImageFormat.fromJS(_data["rawFormat"]) : <any>undefined;
            this.pixelFormat = _data["pixelFormat"];
            if (Array.isArray(_data["propertyIdList"])) {
                (<any>this).propertyIdList = [] as any;
                for (let item of _data["propertyIdList"])
                    (<any>this).propertyIdList.push(item);
            }
            if (Array.isArray(_data["propertyItems"])) {
                (<any>this).propertyItems = [] as any;
                for (let item of _data["propertyItems"])
                    (<any>this).propertyItems.push(PropertyItem.fromJS(item));
            }
            this.palette = _data["palette"] ? ColorPalette.fromJS(_data["palette"]) : <any>undefined;
            if (Array.isArray(_data["frameDimensionsList"])) {
                (<any>this).frameDimensionsList = [] as any;
                for (let item of _data["frameDimensionsList"])
                    (<any>this).frameDimensionsList.push(item);
            }
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag"] = this.tag;
        data["physicalDimension"] = this.physicalDimension ? this.physicalDimension.toJSON() : <any>undefined;
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        data["width"] = this.width;
        data["height"] = this.height;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["flags"] = this.flags;
        data["rawFormat"] = this.rawFormat ? this.rawFormat.toJSON() : <any>undefined;
        data["pixelFormat"] = this.pixelFormat;
        if (Array.isArray(this.propertyIdList)) {
            data["propertyIdList"] = [];
            for (let item of this.propertyIdList)
                data["propertyIdList"].push(item);
        }
        if (Array.isArray(this.propertyItems)) {
            data["propertyItems"] = [];
            for (let item of this.propertyItems)
                data["propertyItems"].push(item.toJSON());
        }
        data["palette"] = this.palette ? this.palette.toJSON() : <any>undefined;
        if (Array.isArray(this.frameDimensionsList)) {
            data["frameDimensionsList"] = [];
            for (let item of this.frameDimensionsList)
                data["frameDimensionsList"].push(item);
        }
        return data;
    }

    clone(): Image {
        const json = this.toJSON();
        let result = new Image();
        result.init(json);
        return result;
    }
}

export interface IImage {
    tag: any | undefined;
    physicalDimension: SizeF;
    size: Size;
    width: number;
    height: number;
    horizontalResolution: number;
    verticalResolution: number;
    flags: number;
    rawFormat: ImageFormat;
    pixelFormat: PixelFormat;
    propertyIdList: number[] | undefined;
    propertyItems: PropertyItem[] | undefined;
    palette: ColorPalette;
    frameDimensionsList: string[] | undefined;
}

export class ImageFormat implements IImageFormat {
    guid: string;

    constructor(data?: IImageFormat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
        }
    }

    static fromJS(data: any): ImageFormat {
        data = typeof data === 'object' ? data : {};
        let result = new ImageFormat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        return data;
    }

    clone(): ImageFormat {
        const json = this.toJSON();
        let result = new ImageFormat();
        result.init(json);
        return result;
    }
}

export interface IImageFormat {
    guid: string;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export enum LandingStatus {
    _1 = 1,
    _2 = 2,
}

export class LastAdvertiseInsertedOut implements ILastAdvertiseInsertedOut {
    id: number | undefined;
    success: boolean;
    error: string | undefined;

    constructor(data?: ILastAdvertiseInsertedOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): LastAdvertiseInsertedOut {
        data = typeof data === 'object' ? data : {};
        let result = new LastAdvertiseInsertedOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }

    clone(): LastAdvertiseInsertedOut {
        const json = this.toJSON();
        let result = new LastAdvertiseInsertedOut();
        result.init(json);
        return result;
    }
}

export interface ILastAdvertiseInsertedOut {
    id: number | undefined;
    success: boolean;
    error: string | undefined;
}

export class Layout implements ILayout {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
    advertisement: Advertisement;

    constructor(data?: ILayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Layout {
        data = typeof data === 'object' ? data : {};
        let result = new Layout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        return data;
    }

    clone(): Layout {
        const json = this.toJSON();
        let result = new Layout();
        result.init(json);
        return result;
    }
}

export interface ILayout {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
    advertisement: Advertisement;
}

export class LayoutDto implements ILayoutDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;

    constructor(data?: ILayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): LayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): LayoutDto {
        const json = this.toJSON();
        let result = new LayoutDto();
        result.init(json);
        return result;
    }
}

export interface ILayoutDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
}

export enum LoginType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class MailData implements IMailData {
    useDefaultCredentials: boolean;
    enableSsl: boolean;
    host: string | undefined;
    port: number;
    sender: string | undefined;
    password: string | undefined;

    constructor(data?: IMailData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useDefaultCredentials = _data["useDefaultCredentials"];
            this.enableSsl = _data["enableSsl"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.sender = _data["sender"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): MailData {
        data = typeof data === 'object' ? data : {};
        let result = new MailData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultCredentials"] = this.useDefaultCredentials;
        data["enableSsl"] = this.enableSsl;
        data["host"] = this.host;
        data["port"] = this.port;
        data["sender"] = this.sender;
        data["password"] = this.password;
        return data;
    }

    clone(): MailData {
        const json = this.toJSON();
        let result = new MailData();
        result.init(json);
        return result;
    }
}

export interface IMailData {
    useDefaultCredentials: boolean;
    enableSsl: boolean;
    host: string | undefined;
    port: number;
    sender: string | undefined;
    password: string | undefined;
}

export enum MrMrsType {
    _1 = 1,
    _2 = 2,
}

export enum MultiTenancySides {
    _1 = 1,
    _2 = 2,
}

export class Notification implements INotification {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    creatorUser: User;
    userId: number;
    user: User;
    adId: number | undefined;
    advertisement: Advertisement;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.adId = _data["adId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
            this.type = _data["type"];
            this.description = _data["description"];
            this.isRead = _data["isRead"];
            this.brokerId = _data["brokerId"];
            this.seekerId = _data["seekerId"];
            this.ownerId = _data["ownerId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["adId"] = this.adId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["description"] = this.description;
        data["isRead"] = this.isRead;
        data["brokerId"] = this.brokerId;
        data["seekerId"] = this.seekerId;
        data["ownerId"] = this.ownerId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): Notification {
        const json = this.toJSON();
        let result = new Notification();
        result.init(json);
        return result;
    }
}

export interface INotification {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    creatorUser: User;
    userId: number;
    user: User;
    adId: number | undefined;
    advertisement: Advertisement;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    brokerId: number | undefined;
    seekerId: number | undefined;
    ownerId: number | undefined;
    companyId: number | undefined;
}

export class NotificationDto implements INotificationDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    adId: number | undefined;
    advertisement: AdvertisementDto;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    time: string | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.adId = _data["adId"];
            this.advertisement = _data["advertisement"] ? AdvertisementDto.fromJS(_data["advertisement"]) : <any>undefined;
            this.type = _data["type"];
            this.description = _data["description"];
            this.isRead = _data["isRead"];
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["adId"] = this.adId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["description"] = this.description;
        data["isRead"] = this.isRead;
        data["time"] = this.time;
        return data;
    }

    clone(): NotificationDto {
        const json = this.toJSON();
        let result = new NotificationDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    adId: number | undefined;
    advertisement: AdvertisementDto;
    type: NotificationTypes;
    description: string | undefined;
    isRead: boolean | undefined;
    time: string | undefined;
}

export class NotificationDtoPagedResultDto implements INotificationDtoPagedResultDto {
    items: NotificationDto[] | undefined;
    totalCount: number;

    constructor(data?: INotificationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NotificationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NotificationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NotificationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NotificationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDtoPagedResultDto {
    items: NotificationDto[] | undefined;
    totalCount: number;
}

export enum NotificationTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum OfficiesType {
    _1 = 1,
    _2 = 2,
}

export class Order implements IOrder {
    column: number;
    dir: string | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.dir = _data["dir"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["dir"] = this.dir;
        return data;
    }

    clone(): Order {
        const json = this.toJSON();
        let result = new Order();
        result.init(json);
        return result;
    }
}

export interface IOrder {
    column: number;
    dir: string | undefined;
}

export class OtpRequestModel implements IOtpRequestModel {
    phoneNumber: string | undefined;

    constructor(data?: IOtpRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): OtpRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new OtpRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): OtpRequestModel {
        const json = this.toJSON();
        let result = new OtpRequestModel();
        result.init(json);
        return result;
    }
}

export interface IOtpRequestModel {
    phoneNumber: string | undefined;
}

export class OtpResponseModel implements IOtpResponseModel {
    message: string | undefined;
    otp: string | undefined;
    isSuccess: boolean;

    constructor(data?: IOtpResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.otp = _data["otp"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): OtpResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new OtpResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["otp"] = this.otp;
        data["isSuccess"] = this.isSuccess;
        return data;
    }

    clone(): OtpResponseModel {
        const json = this.toJSON();
        let result = new OtpResponseModel();
        result.init(json);
        return result;
    }
}

export interface IOtpResponseModel {
    message: string | undefined;
    otp: string | undefined;
    isSuccess: boolean;
}

export class Owner implements IOwner {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;

    constructor(data?: IOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? Package.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): Owner {
        data = typeof data === 'object' ? data : {};
        let result = new Owner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): Owner {
        const json = this.toJSON();
        let result = new Owner();
        result.init(json);
        return result;
    }
}

export interface IOwner {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;
}

export class OwnerDto implements IOwnerDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;

    constructor(data?: IOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.aboutAr = _data["aboutAr"];
            this.aboutEn = _data["aboutEn"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? PackageDto.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): OwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["aboutAr"] = this.aboutAr;
        data["aboutEn"] = this.aboutEn;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): OwnerDto {
        const json = this.toJSON();
        let result = new OwnerDto();
        result.init(json);
        return result;
    }
}

export interface IOwnerDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;
}

export class OwnerDtoDataTableOutputDto implements IOwnerDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: OwnerDto[] | undefined;

    constructor(data?: IOwnerDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(OwnerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OwnerDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): OwnerDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new OwnerDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IOwnerDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: OwnerDto[] | undefined;
}

export class OwnerLoginInfoDto implements IOwnerLoginInfoDto {
    id: number;
    name: string | undefined;

    constructor(data?: IOwnerLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OwnerLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): OwnerLoginInfoDto {
        const json = this.toJSON();
        let result = new OwnerLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IOwnerLoginInfoDto {
    id: number;
    name: string | undefined;
}

export class Package implements IPackage {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    price: number;
    points: number;

    constructor(data?: IPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.price = _data["price"];
            this.points = _data["points"];
        }
    }

    static fromJS(data: any): Package {
        data = typeof data === 'object' ? data : {};
        let result = new Package();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["price"] = this.price;
        data["points"] = this.points;
        return data;
    }

    clone(): Package {
        const json = this.toJSON();
        let result = new Package();
        result.init(json);
        return result;
    }
}

export interface IPackage {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    price: number;
    points: number;
}

export class PackageDto implements IPackageDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    price: number;
    points: number;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.price = _data["price"];
            this.points = _data["points"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["price"] = this.price;
        data["points"] = this.points;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): PackageDto {
        const json = this.toJSON();
        let result = new PackageDto();
        result.init(json);
        return result;
    }
}

export interface IPackageDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    price: number;
    points: number;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class PackageDtoDataTableOutputDto implements IPackageDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: PackageDto[] | undefined;

    constructor(data?: IPackageDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(PackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): PackageDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new PackageDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IPackageDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: PackageDto[] | undefined;
}

export enum PaymentFacilitiesType {
    _1 = 1,
    _2 = 2,
}

export class PaymentRequestModel implements IPaymentRequestModel {
    amount: number;
    userId: number;

    constructor(data?: IPaymentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PaymentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["userId"] = this.userId;
        return data;
    }

    clone(): PaymentRequestModel {
        const json = this.toJSON();
        let result = new PaymentRequestModel();
        result.init(json);
        return result;
    }
}

export interface IPaymentRequestModel {
    amount: number;
    userId: number;
}

export class PaymentResponseModel implements IPaymentResponseModel {
    url: string | undefined;
    isSuccess: boolean;

    constructor(data?: IPaymentResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): PaymentResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["isSuccess"] = this.isSuccess;
        return data;
    }

    clone(): PaymentResponseModel {
        const json = this.toJSON();
        let result = new PaymentResponseModel();
        result.init(json);
        return result;
    }
}

export interface IPaymentResponseModel {
    url: string | undefined;
    isSuccess: boolean;
}

export class PermissionCustomDto implements IPermissionCustomDto {
    name: string | undefined;
    displayName: string | undefined;
    systemName: string | undefined;
    description: string | undefined;
    multiTenancySides: MultiTenancySides;
    children: PermissionCustomDto[] | undefined;

    constructor(data?: IPermissionCustomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.systemName = _data["systemName"];
            this.description = _data["description"];
            this.multiTenancySides = _data["multiTenancySides"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(PermissionCustomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionCustomDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionCustomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["systemName"] = this.systemName;
        data["description"] = this.description;
        data["multiTenancySides"] = this.multiTenancySides;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionCustomDto {
        const json = this.toJSON();
        let result = new PermissionCustomDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionCustomDto {
    name: string | undefined;
    displayName: string | undefined;
    systemName: string | undefined;
    description: string | undefined;
    multiTenancySides: MultiTenancySides;
    children: PermissionCustomDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class Photo implements IPhoto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
    advertisement: Advertisement;

    constructor(data?: IPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.advertisementId = _data["advertisementId"];
            this.advertisement = _data["advertisement"] ? Advertisement.fromJS(_data["advertisement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Photo {
        data = typeof data === 'object' ? data : {};
        let result = new Photo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["advertisementId"] = this.advertisementId;
        data["advertisement"] = this.advertisement ? this.advertisement.toJSON() : <any>undefined;
        return data;
    }

    clone(): Photo {
        const json = this.toJSON();
        let result = new Photo();
        result.init(json);
        return result;
    }
}

export interface IPhoto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
    advertisement: Advertisement;
}

export class PhotoDto implements IPhotoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;

    constructor(data?: IPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.advertisementId = _data["advertisementId"];
        }
    }

    static fromJS(data: any): PhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["advertisementId"] = this.advertisementId;
        return data;
    }

    clone(): PhotoDto {
        const json = this.toJSON();
        let result = new PhotoDto();
        result.init(json);
        return result;
    }
}

export interface IPhotoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    advertisementId: number;
}

export enum PixelFormat {
    _0 = 0,
    _15 = 15,
    _65536 = 65536,
    _131072 = 131072,
    _135173 = 135173,
    _135174 = 135174,
    _137224 = 137224,
    _139273 = 139273,
    _196865 = 196865,
    _197634 = 197634,
    _198659 = 198659,
    _262144 = 262144,
    _397319 = 397319,
    _524288 = 524288,
    _925707 = 925707,
    _1048576 = 1048576,
    _1052676 = 1052676,
    _1060876 = 1060876,
    _1851406 = 1851406,
    _2097152 = 2097152,
    _2498570 = 2498570,
    _3424269 = 3424269,
}

export class PlaceAdsDurationInput implements IPlaceAdsDurationInput {
    ads: number[] | undefined;
    durationId: number | undefined;
    isPublish: boolean | undefined;

    constructor(data?: IPlaceAdsDurationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ads"])) {
                this.ads = [] as any;
                for (let item of _data["ads"])
                    this.ads.push(item);
            }
            this.durationId = _data["durationId"];
            this.isPublish = _data["isPublish"];
        }
    }

    static fromJS(data: any): PlaceAdsDurationInput {
        data = typeof data === 'object' ? data : {};
        let result = new PlaceAdsDurationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ads)) {
            data["ads"] = [];
            for (let item of this.ads)
                data["ads"].push(item);
        }
        data["durationId"] = this.durationId;
        data["isPublish"] = this.isPublish;
        return data;
    }

    clone(): PlaceAdsDurationInput {
        const json = this.toJSON();
        let result = new PlaceAdsDurationInput();
        result.init(json);
        return result;
    }
}

export interface IPlaceAdsDurationInput {
    ads: number[] | undefined;
    durationId: number | undefined;
    isPublish: boolean | undefined;
}

export class PlaceDurationInput implements IPlaceDurationInput {
    projectId: number | undefined;
    durationId: number | undefined;
    isPublish: boolean | undefined;

    constructor(data?: IPlaceDurationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.durationId = _data["durationId"];
            this.isPublish = _data["isPublish"];
        }
    }

    static fromJS(data: any): PlaceDurationInput {
        data = typeof data === 'object' ? data : {};
        let result = new PlaceDurationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["durationId"] = this.durationId;
        data["isPublish"] = this.isPublish;
        return data;
    }

    clone(): PlaceDurationInput {
        const json = this.toJSON();
        let result = new PlaceDurationInput();
        result.init(json);
        return result;
    }
}

export interface IPlaceDurationInput {
    projectId: number | undefined;
    durationId: number | undefined;
    isPublish: boolean | undefined;
}

export class Project implements IProject {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    description: string | undefined;
    photos: ProjectPhoto[] | undefined;
    layouts: ProjectLayout[] | undefined;
    advertisements: Advertisement[] | undefined;
    durationId: number | undefined;
    duration: Duration;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    company: Company;
    isPublish: boolean | undefined;
    isApprove: boolean | undefined;
    latitude: number | undefined;
    longitude: number | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(ProjectPhoto.fromJS(item));
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts.push(ProjectLayout.fromJS(item));
            }
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(Advertisement.fromJS(item));
            }
            this.durationId = _data["durationId"];
            this.duration = _data["duration"] ? Duration.fromJS(_data["duration"]) : <any>undefined;
            this.featuredAd = _data["featuredAd"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        data["durationId"] = this.durationId;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["featuredAd"] = this.featuredAd;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): Project {
        const json = this.toJSON();
        let result = new Project();
        result.init(json);
        return result;
    }
}

export interface IProject {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    description: string | undefined;
    photos: ProjectPhoto[] | undefined;
    layouts: ProjectLayout[] | undefined;
    advertisements: Advertisement[] | undefined;
    durationId: number | undefined;
    duration: Duration;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    company: Company;
    isPublish: boolean | undefined;
    isApprove: boolean | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class ProjectDto implements IProjectDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    description: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    durationId: number | undefined;
    duration: DurationDto;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    company: CompanyDto;
    isPublish: boolean;
    isApprove: boolean | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisements: AdvertisementDto[] | undefined;
    photos: ProjectPhotoDto[] | undefined;
    layouts: ProjectLayoutDto[] | undefined;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.durationId = _data["durationId"];
            this.duration = _data["duration"] ? DurationDto.fromJS(_data["duration"]) : <any>undefined;
            this.featuredAd = _data["featuredAd"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.isPublish = _data["isPublish"];
            this.isApprove = _data["isApprove"];
            if (Array.isArray(_data["photosList"])) {
                this.photosList = [] as any;
                for (let item of _data["photosList"])
                    this.photosList.push(item);
            }
            if (Array.isArray(_data["layoutsList"])) {
                this.layoutsList = [] as any;
                for (let item of _data["layoutsList"])
                    this.layoutsList.push(item);
            }
            if (Array.isArray(_data["advertisements"])) {
                this.advertisements = [] as any;
                for (let item of _data["advertisements"])
                    this.advertisements.push(AdvertisementDto.fromJS(item));
            }
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos.push(ProjectPhotoDto.fromJS(item));
            }
            if (Array.isArray(_data["layouts"])) {
                this.layouts = [] as any;
                for (let item of _data["layouts"])
                    this.layouts.push(ProjectLayoutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["durationId"] = this.durationId;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["featuredAd"] = this.featuredAd;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["isPublish"] = this.isPublish;
        data["isApprove"] = this.isApprove;
        if (Array.isArray(this.photosList)) {
            data["photosList"] = [];
            for (let item of this.photosList)
                data["photosList"].push(item);
        }
        if (Array.isArray(this.layoutsList)) {
            data["layoutsList"] = [];
            for (let item of this.layoutsList)
                data["layoutsList"].push(item);
        }
        if (Array.isArray(this.advertisements)) {
            data["advertisements"] = [];
            for (let item of this.advertisements)
                data["advertisements"].push(item.toJSON());
        }
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProjectDto {
        const json = this.toJSON();
        let result = new ProjectDto();
        result.init(json);
        return result;
    }
}

export interface IProjectDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    description: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    durationId: number | undefined;
    duration: DurationDto;
    featuredAd: boolean | undefined;
    companyId: number | undefined;
    company: CompanyDto;
    isPublish: boolean;
    isApprove: boolean | undefined;
    photosList: string[] | undefined;
    layoutsList: string[] | undefined;
    advertisements: AdvertisementDto[] | undefined;
    photos: ProjectPhotoDto[] | undefined;
    layouts: ProjectLayoutDto[] | undefined;
}

export class ProjectDtoDataTableOutputDto implements IProjectDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: ProjectDto[] | undefined;

    constructor(data?: IProjectDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(ProjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProjectDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new ProjectDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IProjectDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: ProjectDto[] | undefined;
}

export class ProjectLayout implements IProjectLayout {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
    project: Project;

    constructor(data?: IProjectLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectLayout {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProjectLayout {
        const json = this.toJSON();
        let result = new ProjectLayout();
        result.init(json);
        return result;
    }
}

export interface IProjectLayout {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
    project: Project;
}

export class ProjectLayoutDto implements IProjectLayoutDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;

    constructor(data?: IProjectLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): ProjectLayoutDto {
        const json = this.toJSON();
        let result = new ProjectLayoutDto();
        result.init(json);
        return result;
    }
}

export interface IProjectLayoutDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
}

export class ProjectPhoto implements IProjectPhoto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
    project: Project;

    constructor(data?: IProjectPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectPhoto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }

    clone(): ProjectPhoto {
        const json = this.toJSON();
        let result = new ProjectPhoto();
        result.init(json);
        return result;
    }
}

export interface IProjectPhoto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
    project: Project;
}

export class ProjectPhotoDto implements IProjectPhotoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;

    constructor(data?: IProjectPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectPhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): ProjectPhotoDto {
        const json = this.toJSON();
        let result = new ProjectPhotoDto();
        result.init(json);
        return result;
    }
}

export interface IProjectPhotoDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    avatar: string | undefined;
    projectId: number;
}

export class PropertyItem implements IPropertyItem {
    id: number;
    len: number;
    type: number;
    value: string | undefined;

    constructor(data?: IPropertyItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.len = _data["len"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["len"] = this.len;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }

    clone(): PropertyItem {
        const json = this.toJSON();
        let result = new PropertyItem();
        result.init(json);
        return result;
    }
}

export interface IPropertyItem {
    id: number;
    len: number;
    type: number;
    value: string | undefined;
}

export enum ProximityToTheSeaType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class RateDto implements IRateDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    userRate: number;

    constructor(data?: IRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.userRate = _data["userRate"];
        }
    }

    static fromJS(data: any): RateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userRate"] = this.userRate;
        return data;
    }

    clone(): RateDto {
        const json = this.toJSON();
        let result = new RateDto();
        result.init(json);
        return result;
    }
}

export interface IRateDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    userRate: number;
}

export class RateDtoDataTableOutputDto implements IRateDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: RateDto[] | undefined;

    constructor(data?: IRateDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(RateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RateDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RateDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): RateDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new RateDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IRateDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: RateDto[] | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export enum RentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
    usernameOrEmailAddress: string | undefined;
    resetCode: string | undefined;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.resetCode = _data["resetCode"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["resetCode"] = this.resetCode;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
    usernameOrEmailAddress: string | undefined;
    resetCode: string | undefined;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class SaveSettingsInput implements ISaveSettingsInput {
    settings: SettingDto[];

    constructor(data?: ISaveSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(SettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        return data;
    }

    clone(): SaveSettingsInput {
        const json = this.toJSON();
        let result = new SaveSettingsInput();
        result.init(json);
        return result;
    }
}

export interface ISaveSettingsInput {
    settings: SettingDto[];
}

export class SaveUserPermissionsInput implements ISaveUserPermissionsInput {
    userId: number;
    tenantId: number | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ISaveUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): SaveUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new SaveUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): SaveUserPermissionsInput {
        const json = this.toJSON();
        let result = new SaveUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface ISaveUserPermissionsInput {
    userId: number;
    tenantId: number | undefined;
    grantedPermissions: string[] | undefined;
}

export class Search implements ISearch {
    regex: boolean;
    value: string | undefined;

    constructor(data?: ISearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regex = _data["regex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Search {
        data = typeof data === 'object' ? data : {};
        let result = new Search();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regex"] = this.regex;
        data["value"] = this.value;
        return data;
    }

    clone(): Search {
        const json = this.toJSON();
        let result = new Search();
        result.init(json);
        return result;
    }
}

export interface ISearch {
    regex: boolean;
    value: string | undefined;
}

export class Seeker implements ISeeker {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;

    constructor(data?: ISeeker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? Package.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): Seeker {
        data = typeof data === 'object' ? data : {};
        let result = new Seeker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): Seeker {
        const json = this.toJSON();
        let result = new Seeker();
        result.init(json);
        return result;
    }
}

export interface ISeeker {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: User;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    packageId: number | undefined;
    package: Package;
    balance: number | undefined;
}

export class SeekerDto implements ISeekerDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;

    constructor(data?: ISeekerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.secondMobile = _data["secondMobile"];
            this.avatar = _data["avatar"];
            this.isActive = _data["isActive"];
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.userPassword = _data["userPassword"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.aboutAr = _data["aboutAr"];
            this.aboutEn = _data["aboutEn"];
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.package = _data["package"] ? PackageDto.fromJS(_data["package"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): SeekerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeekerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["secondMobile"] = this.secondMobile;
        data["avatar"] = this.avatar;
        data["isActive"] = this.isActive;
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["userPassword"] = this.userPassword;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["aboutAr"] = this.aboutAr;
        data["aboutEn"] = this.aboutEn;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["package"] = this.package ? this.package.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): SeekerDto {
        const json = this.toJSON();
        let result = new SeekerDto();
        result.init(json);
        return result;
    }
}

export interface ISeekerDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number;
    user: UserDto;
    secondMobile: string | undefined;
    avatar: string | undefined;
    isActive: boolean;
    userName: string | undefined;
    userSurname: string | undefined;
    userEmailAddress: string | undefined;
    userPhoneNumber: string | undefined;
    userPassword: string | undefined;
    birthDate: moment.Moment | undefined;
    aboutAr: string | undefined;
    aboutEn: string | undefined;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
    packageId: number | undefined;
    package: PackageDto;
    balance: number | undefined;
}

export class SeekerDtoDataTableOutputDto implements ISeekerDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: SeekerDto[] | undefined;

    constructor(data?: ISeekerDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(SeekerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeekerDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeekerDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): SeekerDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new SeekerDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISeekerDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: SeekerDto[] | undefined;
}

export class SeekerLoginInfoDto implements ISeekerLoginInfoDto {
    id: number;
    name: string | undefined;

    constructor(data?: ISeekerLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SeekerLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeekerLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): SeekerLoginInfoDto {
        const json = this.toJSON();
        let result = new SeekerLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ISeekerLoginInfoDto {
    id: number;
    name: string | undefined;
}

export class SendPushNotificationInput implements ISendPushNotificationInput {
    registeredDeviceId: number;
    message: string | undefined;

    constructor(data?: ISendPushNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredDeviceId = _data["registeredDeviceId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendPushNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPushNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredDeviceId"] = this.registeredDeviceId;
        data["message"] = this.message;
        return data;
    }

    clone(): SendPushNotificationInput {
        const json = this.toJSON();
        let result = new SendPushNotificationInput();
        result.init(json);
        return result;
    }
}

export interface ISendPushNotificationInput {
    registeredDeviceId: number;
    message: string | undefined;
}

export class Setting implements ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export class SettingDefinition implements ISettingDefinition {
    name: string | undefined;
    displayName: ILocalizableString;
    description: ILocalizableString;
    scopes: SettingScopes;
    isInherited: boolean;
    group: SettingDefinitionGroup;
    defaultValue: string | undefined;
    clientVisibilityProvider: ISettingClientVisibilityProvider;
    customData: any | undefined;
    isEncrypted: boolean;

    constructor(data?: ISettingDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"] ? ILocalizableString.fromJS(_data["displayName"]) : <any>undefined;
            this.description = _data["description"] ? ILocalizableString.fromJS(_data["description"]) : <any>undefined;
            this.scopes = _data["scopes"];
            this.isInherited = _data["isInherited"];
            this.group = _data["group"] ? SettingDefinitionGroup.fromJS(_data["group"]) : <any>undefined;
            this.defaultValue = _data["defaultValue"];
            this.clientVisibilityProvider = _data["clientVisibilityProvider"] ? ISettingClientVisibilityProvider.fromJS(_data["clientVisibilityProvider"]) : <any>undefined;
            this.customData = _data["customData"];
            this.isEncrypted = _data["isEncrypted"];
        }
    }

    static fromJS(data: any): SettingDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["scopes"] = this.scopes;
        data["isInherited"] = this.isInherited;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["defaultValue"] = this.defaultValue;
        data["clientVisibilityProvider"] = this.clientVisibilityProvider ? this.clientVisibilityProvider.toJSON() : <any>undefined;
        data["customData"] = this.customData;
        data["isEncrypted"] = this.isEncrypted;
        return data;
    }

    clone(): SettingDefinition {
        const json = this.toJSON();
        let result = new SettingDefinition();
        result.init(json);
        return result;
    }
}

export interface ISettingDefinition {
    name: string | undefined;
    displayName: ILocalizableString;
    description: ILocalizableString;
    scopes: SettingScopes;
    isInherited: boolean;
    group: SettingDefinitionGroup;
    defaultValue: string | undefined;
    clientVisibilityProvider: ISettingClientVisibilityProvider;
    customData: any | undefined;
    isEncrypted: boolean;
}

export class SettingDefinitionGroup implements ISettingDefinitionGroup {
    name: string | undefined;
    displayName: ILocalizableString;
    parent: SettingDefinitionGroup;
    readonly children: SettingDefinitionGroup[] | undefined;

    constructor(data?: ISettingDefinitionGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"] ? ILocalizableString.fromJS(_data["displayName"]) : <any>undefined;
            this.parent = _data["parent"] ? SettingDefinitionGroup.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["children"])
                    (<any>this).children.push(SettingDefinitionGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SettingDefinitionGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDefinitionGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }

    clone(): SettingDefinitionGroup {
        const json = this.toJSON();
        let result = new SettingDefinitionGroup();
        result.init(json);
        return result;
    }
}

export interface ISettingDefinitionGroup {
    name: string | undefined;
    displayName: ILocalizableString;
    parent: SettingDefinitionGroup;
    children: SettingDefinitionGroup[] | undefined;
}

export class SettingDto implements ISettingDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    name: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    value: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["value"] = this.value;
        return data;
    }

    clone(): SettingDto {
        const json = this.toJSON();
        let result = new SettingDto();
        result.init(json);
        return result;
    }
}

export interface ISettingDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    name: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    value: string | undefined;
}

export enum SettingScopes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _7 = 7,
}

export class Size implements ISize {
    readonly isEmpty: boolean;
    width: number;
    height: number;

    constructor(data?: ISize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isEmpty = _data["isEmpty"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Size {
        data = typeof data === 'object' ? data : {};
        let result = new Size();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmpty"] = this.isEmpty;
        data["width"] = this.width;
        data["height"] = this.height;
        return data;
    }

    clone(): Size {
        const json = this.toJSON();
        let result = new Size();
        result.init(json);
        return result;
    }
}

export interface ISize {
    isEmpty: boolean;
    width: number;
    height: number;
}

export class SizeF implements ISizeF {
    readonly isEmpty: boolean;
    width: number;
    height: number;

    constructor(data?: ISizeF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isEmpty = _data["isEmpty"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): SizeF {
        data = typeof data === 'object' ? data : {};
        let result = new SizeF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmpty"] = this.isEmpty;
        data["width"] = this.width;
        data["height"] = this.height;
        return data;
    }

    clone(): SizeF {
        const json = this.toJSON();
        let result = new SizeF();
        result.init(json);
        return result;
    }
}

export interface ISizeF {
    isEmpty: boolean;
    width: number;
    height: number;
}

export class SocialContactDto implements ISocialContactDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    socialName: string | undefined;
    socialValue: string | undefined;
    avatar: string | undefined;

    constructor(data?: ISocialContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.socialName = _data["socialName"];
            this.socialValue = _data["socialValue"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): SocialContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["socialName"] = this.socialName;
        data["socialValue"] = this.socialValue;
        data["avatar"] = this.avatar;
        return data;
    }

    clone(): SocialContactDto {
        const json = this.toJSON();
        let result = new SocialContactDto();
        result.init(json);
        return result;
    }
}

export interface ISocialContactDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    socialName: string | undefined;
    socialValue: string | undefined;
    avatar: string | undefined;
}

export class SocialContactDtoDataTableOutputDto implements ISocialContactDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: SocialContactDto[] | undefined;

    constructor(data?: ISocialContactDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(SocialContactDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SocialContactDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialContactDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): SocialContactDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new SocialContactDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISocialContactDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: SocialContactDto[] | undefined;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export enum TransactionType {
    _1 = 1,
    _2 = 2,
}

export class User implements IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    isMobileUser: boolean;
    isWhatsApped: boolean;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isMobileUser = _data["isMobileUser"];
            this.isWhatsApped = _data["isWhatsApped"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isMobileUser"] = this.isMobileUser;
        data["isWhatsApped"] = this.isWhatsApped;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    isMobileUser: boolean;
    isWhatsApped: boolean;
}

export class UserClaim implements IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDevice implements IUserDevice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    creatorUser: User;
    userId: number | undefined;
    user: User;
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    registrationToken: string | undefined;

    constructor(data?: IUserDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.type = _data["type"];
            this.deviceName = _data["deviceName"];
            this.ipAddress = _data["ipAddress"];
            this.registrationToken = _data["registrationToken"];
        }
    }

    static fromJS(data: any): UserDevice {
        data = typeof data === 'object' ? data : {};
        let result = new UserDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["registrationToken"] = this.registrationToken;
        return data;
    }

    clone(): UserDevice {
        const json = this.toJSON();
        let result = new UserDevice();
        result.init(json);
        return result;
    }
}

export interface IUserDevice {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    creatorUser: User;
    userId: number | undefined;
    user: User;
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    registrationToken: string | undefined;
}

export class UserDeviceDto implements IUserDeviceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number | undefined;
    user: UserDto;
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    registrationToken: string | undefined;

    constructor(data?: IUserDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.type = _data["type"];
            this.deviceName = _data["deviceName"];
            this.ipAddress = _data["ipAddress"];
            this.registrationToken = _data["registrationToken"];
        }
    }

    static fromJS(data: any): UserDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["registrationToken"] = this.registrationToken;
        return data;
    }

    clone(): UserDeviceDto {
        const json = this.toJSON();
        let result = new UserDeviceDto();
        result.init(json);
        return result;
    }
}

export interface IUserDeviceDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creatorUser: User;
    lastModifierUser: User;
    isDeleted: boolean;
    deleterUser: User;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    userId: number | undefined;
    user: UserDto;
    type: DeviceTypes;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    registrationToken: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
}

export class UserDtoDataTableOutputDto implements IUserDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: UserDto[] | undefined;

    constructor(data?: IUserDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new UserDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: UserDto[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
}

export enum UsingFor {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class WalletDto implements IWalletDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    companyId: number;
    company: CompanyDto;
    type: TransactionType;
    amount: number | undefined;
    points: number | undefined;
    transactionTime: moment.Moment;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.points = _data["points"];
            this.transactionTime = _data["transactionTime"] ? moment(_data["transactionTime"].toString()) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? UserDto.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? UserDto.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.deleterUser = _data["deleterUser"] ? UserDto.fromJS(_data["deleterUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["points"] = this.points;
        data["transactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): WalletDto {
        const json = this.toJSON();
        let result = new WalletDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    companyId: number;
    company: CompanyDto;
    type: TransactionType;
    amount: number | undefined;
    points: number | undefined;
    transactionTime: moment.Moment;
    creatorUser: UserDto;
    lastModifierUser: UserDto;
    deleterUser: UserDto;
}

export class WalletDtoDataTableOutputDto implements IWalletDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: WalletDto[] | undefined;

    constructor(data?: IWalletDtoDataTableOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockValue = _data["stockValue"];
            this.draw = _data["draw"];
            this.actionResult = _data["actionResult"];
            this.iTotalRecords = _data["iTotalRecords"];
            this.iTotalDisplayRecords = _data["iTotalDisplayRecords"];
            if (Array.isArray(_data["aaData"])) {
                this.aaData = [] as any;
                for (let item of _data["aaData"])
                    this.aaData.push(WalletDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletDtoDataTableOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoDataTableOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockValue"] = this.stockValue;
        data["draw"] = this.draw;
        data["actionResult"] = this.actionResult;
        data["iTotalRecords"] = this.iTotalRecords;
        data["iTotalDisplayRecords"] = this.iTotalDisplayRecords;
        if (Array.isArray(this.aaData)) {
            data["aaData"] = [];
            for (let item of this.aaData)
                data["aaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): WalletDtoDataTableOutputDto {
        const json = this.toJSON();
        let result = new WalletDtoDataTableOutputDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDtoDataTableOutputDto {
    stockValue: number | undefined;
    draw: number;
    actionResult: string | undefined;
    iTotalRecords: number;
    iTotalDisplayRecords: number;
    aaData: WalletDto[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}